#!/usr/bin/env python
import contextlib as __scriptmerge_contextlib

@__scriptmerge_contextlib.contextmanager
def __scriptmerge_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __scriptmerge_temporary_dir() as __scriptmerge_working_dir:
    def __scriptmerge_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __scriptmerge_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__scriptmerge_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __scriptmerge_sys
    __scriptmerge_sys.path.insert(0, __scriptmerge_working_dir)

    __scriptmerge_write_module('lib/__init__.py', b'')
    __scriptmerge_write_module('lib/msgbox.py', b'from __future__ import annotations\nfrom typing import cast\nfrom ooodev.utils.lo import Lo\nfrom com.sun.star.awt import XToolkit2\nfrom com.sun.star.awt import XMessageBox\nfrom ooo.dyn.awt.message_box_results import MessageBoxResultsEnum as MessageBoxResultsEnum\nfrom ooo.dyn.awt.message_box_buttons import MessageBoxButtonsEnum as MessageBoxButtonsEnum\nfrom ooo.dyn.awt.message_box_type import MessageBoxType as MessageBoxType\ndef msgbox(\n    message: str,\n    title: str = "Message",\n    boxtype: MessageBoxType = MessageBoxType.MESSAGEBOX,\n    buttons: MessageBoxButtonsEnum | int = MessageBoxButtonsEnum.BUTTONS_OK,\n) -> MessageBoxResultsEnum:\n    if boxtype == MessageBoxType.INFOBOX:\n        _buttons = MessageBoxButtonsEnum.BUTTONS_OK.value\n    else:\n        _buttons = buttons\n    Lo.load_office()\n    tk = Lo.create_instance_mcf(XToolkit2, "com.sun.star.awt.Toolkit")\n    parent = tk.getDesktopWindow()\n    box = cast(XMessageBox, tk.createMessageBox(parent, boxtype, int(_buttons), str(title), str(message)))\n    return MessageBoxResultsEnum(int(box.execute()))\n__all__ = ["msgbox"]\n')
    __scriptmerge_write_module('ooodev/__init__.py', b'__version__ = "0.4.21"\n')
    __scriptmerge_write_module('ooodev/utils/__init__.py', b'')
    __scriptmerge_write_module('ooodev/utils/lo.py', b'from __future__ import annotations\nfrom datetime import datetime, timezone\nimport time\nimport types\nfrom typing import TYPE_CHECKING, Any, Iterable, Optional, List, Tuple, cast, overload, Type\nfrom urllib.parse import urlparse\nimport uno\nfrom enum import IntEnum, Enum\nfrom ..mock import mock_g\nfrom ..events.event_singleton import _Events\nfrom ..events.lo_named_event import LoNamedEvent\nfrom ..events.gbl_named_event import GblNamedEvent\nfrom ..events.args.event_args import EventArgs\nfrom ..events.args.cancel_event_args import CancelEventArgs\nfrom ..events.args.dispatch_args import DispatchArgs\nfrom ..events.args.dispatch_cancel_args import DispatchCancelArgs\nfrom ..meta.static_meta import StaticProperty, classproperty\nfrom ..conn.connect import ConnectBase, LoPipeStart, LoSocketStart, LoDirectStart\nfrom ..conn import connectors\nfrom ..conn import cache as mCache\nfrom ..listeners.x_event_adapter import XEventAdapter\nfrom com.sun.star.lang import XComponent\nfrom com.sun.star.beans import XPropertySet\nfrom com.sun.star.beans import XIntrospection\nfrom com.sun.star.container import XNamed\nfrom com.sun.star.frame import XDesktop\nfrom com.sun.star.frame import XDispatchHelper\nfrom com.sun.star.lang import XMultiServiceFactory\nfrom com.sun.star.io import IOException\nfrom com.sun.star.util import XCloseable\nfrom com.sun.star.util import XNumberFormatsSupplier\nfrom com.sun.star.frame import XComponentLoader\nfrom com.sun.star.frame import XModel\nfrom com.sun.star.frame import XStorable\nif TYPE_CHECKING:\n    from com.sun.star.beans import PropertyValue\n    from com.sun.star.container import XChild\n    from com.sun.star.container import XIndexAccess\n    from com.sun.star.frame import XFrame\n    from com.sun.star.lang import EventObject\n    from com.sun.star.lang import XMultiComponentFactory\n    from com.sun.star.lang import XTypeProvider\n    from com.sun.star.lang import XComponent\n    from com.sun.star.script.provider import XScriptContext\n    from com.sun.star.uno import XComponentContext\n    from com.sun.star.uno import XInterface\nfrom ooo.dyn.document.macro_exec_mode import MacroExecMode  \nfrom ooo.dyn.lang.disposed_exception import DisposedException\nfrom ooo.dyn.util.close_veto_exception import CloseVetoException\nfrom . import script_context\nfrom . import props as mProps\nfrom . import file_io as mFileIO\nfrom . import xml_util as mXML\nfrom . import info as mInfo\nfrom ..exceptions import ex as mEx\nfrom .type_var import PathOrStr, UnoInterface, T\nclass Lo(metaclass=StaticProperty):\n    class ControllerLock:\n        def __init__(self):\n            self.component = Lo.this_component\n            Lo.lock_controllers()\n        def __enter__(self) -> XComponent:\n            return self.component\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            Lo.unlock_controllers()\n    class Loader:\n        def __init__(\n            self,\n            connector: connectors.ConnectPipe | connectors.ConnectSocket | None,\n            cache_obj: mCache.Cache | None = None,\n        ):\n            self.loader = Lo.load_office(connector=connector, cache_obj=cache_obj)\n        def __enter__(self) -> XComponentLoader:\n            return self.loader\n        def __exit__(self, exc_type, exc_val, exc_tb):\n            Lo.close_office()\n    class DocType(IntEnum):\n        UNKNOWN = 0\n        WRITER = 1\n        BASE = 2\n        CALC = 3\n        DRAW = 4\n        IMPRESS = 5\n        MATH = 6\n        def __str__(self) -> str:\n            return str(self.value)\n    class DocTypeStr(str, Enum):\n        UNKNOWN = "unknown"\n        WRITER = "swriter"\n        BASE = "sbase"\n        CALC = "scalc"\n        DRAW = "sdraw"\n        IMPRESS = "simpress"\n        MATH = "smath"\n        def __str__(self) -> str:\n            return self.value\n    class Service(str, Enum):\n        UNKNOWN = "com.sun.frame.XModel"\n        WRITER = "com.sun.star.text.TextDocument"\n        BASE = "com.sun.star.sdb.OfficeDatabaseDocument"\n        CALC = "com.sun.star.sheet.SpreadsheetDocument"\n        DRAW = "com.sun.star.drawing.DrawingDocument"\n        IMPRESS = "com.sun.star.presentation.PresentationDocument"\n        MATH = "com.sun.star.formula.FormulaProperties"\n        def __str__(self) -> str:\n            return self.value\n    class CLSID(str, Enum):\n        WRITER = "8BC6B165-B1B2-4EDD-aa47-dae2ee689dd6"\n        CALC = "47BBB4CB-CE4C-4E80-a591-42d9ae74950f"\n        DRAW = "4BAB8970-8A3B-45B3-991c-cbeeac6bd5e3"\n        IMPRESS = "9176E48A-637A-4D1F-803b-99d9bfac1047"\n        MATH = "078B7ABA-54FC-457F-8551-6147e776a997"\n        CHART = "12DCAE26-281F-416F-a234-c3086127382e"\n        def __str__(self) -> str:\n            return self.value\n    ConnectPipe = connectors.ConnectPipe\n    ConnectSocket = connectors.ConnectSocket\n    _xcc: XComponentContext = None\n    _doc: XComponent = None\n    _xdesktop: XDesktop = None\n    _mc_factory: XMultiComponentFactory = None\n    _ms_factory: XMultiServiceFactory = None\n    _is_office_terminated: bool = False\n    _lo_inst: ConnectBase = None\n    @overload\n    @staticmethod\n    def qi(atype: Type[T], obj: XTypeProvider) -> T | None:\n        ...\n    @overload\n    @staticmethod\n    def qi(atype: Type[T], obj: XTypeProvider, raise_err: bool) -> T | None:\n        ...\n    @staticmethod\n    def qi(atype: Type[T], obj: XTypeProvider, raise_err: bool = False) -> T | None:\n        result = None\n        if uno.isInterface(atype) and hasattr(obj, "queryInterface"):\n            uno_t = uno.getTypeByName(atype.__pyunointerface__)\n            result = obj.queryInterface(uno_t)\n        if raise_err is True and result is None:\n            raise mEx.MissingInterfaceError(atype)\n        return result\n    @classmethod\n    def get_context(cls) -> XComponentContext:\n        return cls._xcc\n    @classmethod\n    def get_desktop(cls) -> XDesktop:\n        return cls._xdesktop\n    @classmethod\n    def get_component_factory(cls) -> XMultiComponentFactory:\n        return cls._mc_factory\n    @classmethod\n    def get_service_factory(cls) -> XMultiServiceFactory:\n        return cls._bridge_component\n    @classmethod\n    def create_instance_msf(\n        cls, atype: Type[T], service_name: str, msf: XMultiServiceFactory = None, raise_err: bool = False\n    ) -> T:\n        if cls._ms_factory is None:\n            raise Exception("No document found")\n        try:\n            if msf is None:\n                obj = cls._ms_factory.createInstance(service_name)\n            else:\n                obj = msf.createInstance(service_name)\n            if raise_err is True and obj is None:\n                mEx.CreateInstanceMsfError(atype, service_name)\n            interface_obj = cls.qi(atype=atype, obj=obj)\n            if raise_err is True and interface_obj is None:\n                raise mEx.MissingInterfaceError(atype)\n            return interface_obj\n        except mEx.CreateInstanceMsfError:\n            raise\n        except mEx.MissingInterfaceError:\n            raise\n        except Exception as e:\n            raise Exception(f"Couldn\'t create interface for \'{service_name}\'") from e\n    @classmethod\n    def create_instance_mcf(\n        cls, atype: Type[T], service_name: str, args: Tuple[object, ...] | None = None, raise_err: bool = False\n    ) -> T:\n        if cls._xcc is None or cls._mc_factory is None:\n            raise Exception("No office connection found")\n        try:\n            if args is not None:\n                obj = cls._mc_factory.createInstanceWithArgumentsAndContext(service_name, args, cls._xcc)\n            else:\n                obj = cls._mc_factory.createInstanceWithContext(service_name, cls._xcc)\n            if raise_err is True and obj is None:\n                mEx.CreateInstanceMcfError(atype, service_name)\n            interface_obj = cls.qi(atype=atype, obj=obj)\n            if raise_err is True and interface_obj is None:\n                raise mEx.MissingInterfaceError(atype)\n            return interface_obj\n        except mEx.CreateInstanceMcfError:\n            raise\n        except mEx.MissingInterfaceError:\n            raise\n        except Exception as e:\n            raise Exception(f"Couldn\'t create interface for \'{service_name}\'") from e\n    @classmethod\n    def get_parent(cls, a_component: XChild) -> XInterface:\n        return a_component.getParent()\n    @classmethod\n    def load_office(\n        cls,\n        connector: connectors.ConnectPipe | connectors.ConnectSocket | None = None,\n        cache_obj: mCache.Cache | None = None,\n    ) -> XComponentLoader:\n        if mock_g.DOCS_BUILDING:\n            return None\n        cargs = CancelEventArgs(Lo.load_office.__qualname__)\n        cargs.event_data = {\n            "connector": connector,\n        }\n        eargs = EventArgs.from_args(cargs)\n        _Events().trigger(LoNamedEvent.RESET, eargs)\n        _Events().trigger(LoNamedEvent.OFFICE_LOADING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        b_connector = cargs.event_data["connector"]\n        Lo.print("Loading Office...")\n        if b_connector is None:\n            try:\n                cls._lo_inst = LoDirectStart()\n                cls._lo_inst.connect()\n            except Exception as e:\n                Lo.print("Office context could not be created. A connector must be supplied if not running as a macro")\n                Lo.print(f"    {e}")\n                raise SystemExit(1)\n        elif isinstance(b_connector, connectors.ConnectPipe):\n            try:\n                cls._lo_inst = LoPipeStart(connector=b_connector, cache_obj=cache_obj)\n                cls._lo_inst.connect()\n            except Exception as e:\n                Lo.print("Office context could not be created")\n                Lo.print(f"    {e}")\n                raise SystemExit(1)\n        elif isinstance(b_connector, connectors.ConnectSocket):\n            try:\n                cls._lo_inst = LoSocketStart(connector=b_connector, cache_obj=cache_obj)\n                cls._lo_inst.connect()\n            except Exception as e:\n                Lo.print("Office context could not be created")\n                Lo.print(f"    {e}")\n                raise SystemExit(1)\n        else:\n            Lo.print("Invalid Connector type. Fatal Error.")\n            raise SystemExit(1)\n        cls._xcc = cls._lo_inst.ctx\n        cls._mc_factory = cls._xcc.getServiceManager()\n        if cls._mc_factory is None:\n            Lo.print("Office Service Manager is unavailable")\n            raise SystemExit(1)\n        cls._xdesktop = cls.create_instance_mcf(XDesktop, "com.sun.star.frame.Desktop")\n        if cls._xdesktop is None:\n            Lo.print("Could not create a desktop service")\n            raise SystemExit(1)\n        loader = cls.qi(XComponentLoader, cls._xdesktop)\n        if loader is None:\n            Lo.print("Unable to access XComponentLoader")\n            SystemExit(1)\n        _Events().trigger(LoNamedEvent.OFFICE_LOADED, eargs)\n        return loader\n    @classmethod\n    def close_office(cls) -> bool:\n        Lo.print("Closing Office")\n        cargs = CancelEventArgs(Lo.close_office.__qualname__)\n        _Events().trigger(LoNamedEvent.OFFICE_CLOSING, cargs)\n        if cargs.cancel:\n            return False\n        cls._doc = None\n        if cls._xdesktop is None:\n            cls.print("No office connection found")\n            return True\n        if cls._is_office_terminated:\n            cls.print("Office has already been requested to terminate")\n            return cls._is_office_terminated\n        num_tries = 1\n        start = time.time()\n        elapsed = 0\n        seconds = 10\n        while cls._is_office_terminated is False and elapsed < seconds:\n            elapsed = time.time() - start\n            cls._is_office_terminated = cls._try_to_terminate(num_tries)\n            time.sleep(0.5)\n            num_tries += 1\n        if cls._is_office_terminated:\n            eargs = EventArgs.from_args(cargs)\n            _Events().trigger(LoNamedEvent.OFFICE_CLOSED, eargs)\n            _Events().trigger(LoNamedEvent.RESET, eargs)\n        return cls._is_office_terminated\n    @classmethod\n    def _try_to_terminate(cls, num_tries: int) -> bool:\n        try:\n            is_dead = cls._xdesktop.terminate()\n            if is_dead:\n                if num_tries > 1:\n                    cls.print(f"{num_tries}. Office terminated")\n                else:\n                    cls.print("Office terminated")\n            else:\n                cls.print(f"{num_tries}. Office failed to terminate")\n            return is_dead\n        except DisposedException as e:\n            cls.print("Office link disposed")\n            return True\n        except Exception as e:\n            cls.print(f"Termination exception: {e}")\n            return False\n    @classmethod\n    def kill_office(cls) -> None:\n        if cls._lo_inst is None:\n            cls.print("No instance to kill")\n            return\n        try:\n            cls._lo_inst.kill_soffice()\n            cls._is_office_terminated = True\n            eargs = EventArgs(Lo.kill_office.__qualname__)\n            _Events().trigger(LoNamedEvent.OFFICE_CLOSED, eargs)\n            _Events().trigger(LoNamedEvent.RESET, eargs)\n            cls.print("Killed Office")\n        except Exception as e:\n            raise Exception(f"Unbale to kill Office") from e\n    @classmethod\n    def open_flat_doc(cls, fnm: PathOrStr, doc_type: Lo.DocType, loader: XComponentLoader) -> XComponent:\n        nn = mXML.XML.get_flat_fiter_name(doc_type=doc_type)\n        Lo.print(f"Flat filter Name: {nn}")\n        return cls.open_doc(fnm, loader, mProps.Props.make_props(FilterName=nn))\n    @overload\n    @classmethod\n    def open_doc(cls, fnm: PathOrStr, loader: XComponentLoader) -> XComponent:\n        ...\n    @overload\n    @classmethod\n    def open_doc(cls, fnm: PathOrStr, loader: XComponentLoader, props: Iterable[PropertyValue]) -> XComponent:\n        ...\n    @classmethod\n    def open_doc(\n        cls,\n        fnm: PathOrStr,\n        loader: XComponentLoader,\n        props: Optional[Iterable[PropertyValue]] = None,\n    ) -> XComponent:\n        cargs = CancelEventArgs(Lo.open_doc.__qualname__)\n        cargs.event_data = {\n            "fnm": fnm,\n            "loader": loader,\n            "props": props,\n        }\n        eargs = EventArgs.from_args(cargs)\n        _Events().trigger(LoNamedEvent.RESET, eargs)\n        _Events().trigger(LoNamedEvent.DOC_OPENING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        fnm = cargs.event_data["fnm"]\n        if fnm is None:\n            raise Exception("Filename is null")\n        pth = mFileIO.FileIO.get_absolute_path(fnm)\n        if props is None:\n            props = mProps.Props.make_props(Hidden=True)\n        open_file_url = None\n        if not mFileIO.FileIO.is_openable(pth):\n            if cls.is_url(pth):\n                Lo.print(f"Will treat filename as a URL: \'{pth}\'")\n                open_file_url = pth\n            else:\n                raise Exception(f"Unable to get url from file: {pth}")\n        else:\n            Lo.print(f"Opening {pth}")\n            open_file_url = mFileIO.FileIO.fnm_to_url(pth)\n        try:\n            doc = loader.loadComponentFromURL(open_file_url, "_blank", 0, props)\n            cls._ms_factory = cls.qi(XMultiServiceFactory, doc)\n            cls._doc = doc\n            _Events().trigger(LoNamedEvent.DOC_OPENED, eargs)\n            return doc\n        except Exception as e:\n            raise Exception("Unable to open the document") from e\n    @classmethod\n    def open_readonly_doc(cls, fnm: PathOrStr, loader: XComponentLoader) -> XComponent:\n        return cls.open_doc(fnm, loader, mProps.Props.make_props(Hidden=True, ReadOnly=True))\n    @classmethod\n    def ext_to_doc_type(cls, ext: str) -> Lo.DocTypeStr:\n        e = ext.casefold().lstrip(".")\n        if e == "":\n            Lo.print("Empty string: Using writer")\n            return cls.DocTypeStr.WRITER\n        if e == "odt":\n            return cls.DocTypeStr.WRITER\n        elif e == "odp":\n            return cls.DocTypeStr.IMPRESS\n        elif e == "odg":\n            return cls.DocTypeStr.DRAW\n        elif e == "ods":\n            return cls.DocTypeStr.CALC\n        elif e == "odb":\n            return cls.DocTypeStr.BASE\n        elif e == "odf":\n            return cls.DocTypeStr.MATH\n        else:\n            Lo.print(f"Do not recognize extension \'{ext}\'; using writer")\n            return cls.DocTypeStr.WRITER\n    @classmethod\n    def doc_type_str(cls, doc_type_val: Lo.DocType) -> Lo.DocTypeStr:\n        if doc_type_val == cls.DocType.WRITER:\n            return cls.DocTypeStr.WRITER\n        elif doc_type_val == cls.DocType.IMPRESS:\n            return cls.DocTypeStr.IMPRESS\n        elif doc_type_val == cls.DocType.DRAW:\n            return cls.DocTypeStr.DRAW\n        elif doc_type_val == cls.DocType.CALC:\n            return cls.DocTypeStr.CALC\n        elif doc_type_val == cls.DocType.BASE:\n            return cls.DocTypeStr.BASE\n        elif doc_type_val == cls.DocType.MATH:\n            return cls.DocTypeStr.MATH\n        else:\n            Lo.print(f"Do not recognize extension \'{doc_type_val}\'; using writer")\n            return cls.DocTypeStr.WRITER\n    @overload\n    @classmethod\n    def create_doc(cls, doc_type: DocTypeStr, loader: XComponentLoader) -> XComponent:\n        ...\n    @overload\n    @classmethod\n    def create_doc(cls, doc_type: DocTypeStr, loader: XComponentLoader, props: Iterable[PropertyValue]) -> XComponent:\n        ...\n    @classmethod\n    def create_doc(\n        cls,\n        doc_type: Lo.DocTypeStr,\n        loader: XComponentLoader,\n        props: Optional[Iterable[PropertyValue]] = None,\n    ) -> XComponent:\n        cargs = CancelEventArgs(Lo.create_doc.__qualname__)\n        cargs.event_data = {\n            "doc_type": doc_type,\n            "loader": loader,\n            "props": props,\n        }\n        eargs = EventArgs.from_args(cargs)\n        _Events().trigger(LoNamedEvent.RESET, eargs)\n        _Events().trigger(LoNamedEvent.DOC_CREATING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        dtype = Lo.DocTypeStr(cargs.event_data["doc_type"])\n        if props is None:\n            props = mProps.Props.make_props(Hidden=True)\n        Lo.print(f"Creating Office document {dtype}")\n        try:\n            doc = loader.loadComponentFromURL(f"private:factory/{dtype}", "_blank", 0, props)\n            cls._ms_factory = cls.qi(XMultiServiceFactory, doc)\n            if cls._ms_factory is None:\n                raise mEx.MissingInterfaceError(XMultiServiceFactory)\n            cls._doc = doc\n            _Events().trigger(LoNamedEvent.DOC_CREATED, eargs)\n            return cls._doc\n        except Exception as e:\n            raise Exception("Could not create a document") from e\n    @classmethod\n    def create_macro_doc(cls, doc_type: Lo.DocTypeStr, loader: XComponentLoader) -> XComponent:\n        return cls.create_doc(\n            doc_type=doc_type,\n            loader=loader,\n            props=mProps.Props.make_props(Hidden=False, MacroExecutionMode=MacroExecMode.ALWAYS_EXECUTE),\n        )\n    @classmethod\n    def create_doc_from_template(cls, template_path: PathOrStr, loader: XComponentLoader) -> XComponent:\n        cargs = CancelEventArgs(Lo.create_doc_from_template.__qualname__)\n        _Events().trigger(LoNamedEvent.DOC_CREATING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        if not mFileIO.FileIO.is_openable(template_path):\n            raise Exception(f"Template file can not be opened: \'{template_path}\'")\n        Lo.print(f"Opening template: \'{template_path}\'")\n        template_url = mFileIO.FileIO.fnm_to_url(fnm=template_path)\n        props = mProps.Props.make_props(Hidden=True, AsTemplate=True)\n        try:\n            cls._doc = loader.loadComponentFromURL(template_url, "_blank", 0, props)\n            cls._ms_factory = cls.qi(XMultiServiceFactory, cls._doc)\n            if cls._ms_factory is None:\n                raise mEx.MissingInterfaceError(XMultiServiceFactory)\n            _Events().trigger(LoNamedEvent.DOC_CREATED, EventArgs.from_args(cargs))\n            return cls._doc\n        except Exception as e:\n            raise Exception(f"Could not create document from template") from e\n    @classmethod\n    def save(cls, doc: object) -> bool:\n        cargs = CancelEventArgs(Lo.save.__qualname__)\n        cargs.event_data = {"doc": doc}\n        _Events().trigger(LoNamedEvent.DOC_SAVING, cargs)\n        if cargs.cancel:\n            return False\n        store = cls.qi(XStorable, doc, True)\n        try:\n            store.store()\n            cls.print("Saved the document by overwriting")\n        except IOException as e:\n            raise Exception(f"Could not save the document") from e\n        _Events().trigger(LoNamedEvent.DOC_SAVED, EventArgs.from_args(cargs))\n        return True\n    @overload\n    @classmethod\n    def save_doc(cls, doc: object, fnm: PathOrStr) -> bool:\n        ...\n    @overload\n    @classmethod\n    def save_doc(cls, doc: object, fnm: PathOrStr, password: str) -> bool:\n        ...\n    @overload\n    @classmethod\n    def save_doc(cls, doc: object, fnm: PathOrStr, password: str, format: str) -> bool:\n        ...\n    @classmethod\n    def save_doc(cls, doc: object, fnm: PathOrStr, password: str = None, format: str = None) -> bool:\n        cargs = CancelEventArgs(Lo.save_doc.__qualname__)\n        cargs.event_data = {\n            "doc": doc,\n            "fnm": fnm,\n            "password": password,\n            "format": format,\n        }\n        fnm = cargs.event_data["fnm"]\n        password = cargs.event_data["password"]\n        format = cargs.event_data["format"]\n        _Events().trigger(LoNamedEvent.DOC_SAVING, cargs)\n        if cargs.cancel:\n            return False\n        store = cls.qi(XStorable, doc, True)\n        doc_type = mInfo.Info.report_doc_type(doc)\n        kargs = {"fnm": fnm, "store": store, "doc_type": doc_type}\n        if password is not None:\n            kargs["password"] = password\n        if format is None:\n            result = cls.store_doc(**kargs)\n        else:\n            kargs["format"] = format\n            result = cls.store_doc_format(**kargs)\n        if result:\n            _Events().trigger(LoNamedEvent.DOC_SAVED, EventArgs.from_args(cargs))\n        return result\n    @overload\n    @classmethod\n    def store_doc(cls, store: XStorable, doc_type: DocType, fnm: PathOrStr) -> bool:\n        ...\n    @overload\n    @classmethod\n    def store_doc(cls, store: XStorable, doc_type: DocType, fnm: PathOrStr, password: str) -> bool:\n        ...\n    @classmethod\n    def store_doc(cls, store: XStorable, doc_type: Lo.DocType, fnm: PathOrStr, password: Optional[str] = None) -> bool:\n        cargs = CancelEventArgs(Lo.store_doc.__qualname__)\n        cargs.event_data = {\n            "store": store,\n            "doc_type": doc_type,\n            "fnm": fnm,\n            "password": password,\n        }\n        _Events().trigger(LoNamedEvent.DOC_STORING, cargs)\n        if cargs.cancel:\n            return False\n        ext = mInfo.Info.get_ext(fnm)\n        frmt = "Text"\n        if ext is None:\n            Lo.print("Assuming a text format")\n        else:\n            frmt = cls.ext_to_format(ext=ext, doc_type=doc_type)\n        if password is None:\n            cls.store_doc_format(store=store, fnm=fnm, format=frmt)\n        else:\n            cls.store_doc_format(store=store, fnm=fnm, format=frmt, password=password)\n        _Events().trigger(LoNamedEvent.DOC_STORED, EventArgs.from_args(cargs))\n        return True\n    @overload\n    @classmethod\n    def ext_to_format(cls, ext: str) -> str:\n        ...\n    @overload\n    @classmethod\n    def ext_to_format(cls, ext: str, doc_type: DocType) -> str:\n        ...\n    @classmethod\n    def ext_to_format(cls, ext: str, doc_type: Lo.DocType = DocType.UNKNOWN) -> str:\n        dtype = cls.DocType(doc_type)\n        s = ext.lower()\n        if s == "doc":\n            return "MS Word 97"\n        elif s == "docx":\n            return "Office Open XML Text"  \n        elif s == "rtf":\n            if dtype == cls.DocType.CALC:\n                return "Rich Text Format (StarCalc)"\n            else:\n                return "Rich Text Format"\n        elif s == "odt":\n            return "writer8"\n        elif s == "ott":\n            return "writer8_template"\n        elif s == "pdf":\n            if dtype == cls.DocType.WRITER:\n                return "writer_pdf_Export"\n            elif dtype == cls.DocType.IMPRESS:\n                return "impress_pdf_Export"\n            elif dtype == cls.DocType.DRAW:\n                return "draw_pdf_Export"\n            elif dtype == cls.DocType.CALC:\n                return "calc_pdf_Export"\n            elif dtype == cls.DocType.MATH:\n                return "math_pdf_Export"\n            else:\n                return "writer_pdf_Export"  \n        elif s == "txt":\n            return "Text"\n        elif s == "ppt":\n            return "MS PowerPoint 97"\n        elif s == "pptx":\n            return "Impress MS PowerPoint 2007 XML"\n        elif s == "odp":\n            return "impress8"\n        elif s == "odg":\n            return "draw8"\n        elif s == "jpg":\n            if dtype == cls.DocType.IMPRESS:\n                return "impress_jpg_Export"\n            else:\n                return "draw_jpg_Export"\n        elif s == "png":\n            if dtype == cls.DocType.IMPRESS:\n                return "impress_png_Export"\n            else:\n                return "draw_png_Export"\n        elif s == "xls":\n            return "MS Excel 97"\n        elif s == "xlsx":\n            return "Calc MS Excel 2007 XML"\n        elif s == "csv":\n            return "Text - txt - csv (StarCalc)"  \n        elif s == "ods":\n            return "calc8"\n        elif s == "odb":\n            return "StarOffice XML (Base)"\n        elif s == "htm" or s == "html":\n            if dtype == cls.DocType.WRITER:\n                return "HTML (StarWriter)"\n            elif dtype == cls.DocType.IMPRESS:\n                return "impress_html_Export"\n            elif dtype == cls.DocType.DRAW:\n                return "draw_html_Export"\n            elif dtype == cls.DocType.CALC:\n                return "HTML (StarCalc)"\n            else:\n                return "HTML"\n        elif s == "xhtml":\n            if dtype == cls.DocType.WRITER:\n                return "XHTML Writer File"\n            elif dtype == cls.DocType.IMPRESS:\n                return "XHTML Impress File"\n            elif dtype == cls.DocType.DRAW:\n                return "XHTML Draw File"\n            elif dtype == cls.DocType.CALC:\n                return "XHTML Calc File"\n            else:\n                return "XHTML Writer File"\n        elif s == "xml":\n            if dtype == cls.DocType.WRITER:\n                return "OpenDocument Text Flat XML"\n            elif dtype == cls.DocType.IMPRESS:\n                return "OpenDocument Presentation Flat XML"\n            elif dtype == cls.DocType.DRAW:\n                return "OpenDocument Drawing Flat XML"\n            elif dtype == cls.DocType.CALC:\n                return "OpenDocument Spreadsheet Flat XML"\n            else:\n                return "OpenDocument Text Flat XML"\n        else:\n            Lo.print(f"Do not recognize extension \'{ext}\'; using text")\n            return "Text"\n    @overload\n    @classmethod\n    def store_doc_format(cls, store: XStorable, fnm: PathOrStr, format: str) -> bool:\n        ...\n    @overload\n    @classmethod\n    def store_doc_format(cls, store: XStorable, fnm: PathOrStr, format: str, password: str) -> bool:\n        ...\n    @classmethod\n    def store_doc_format(cls, store: XStorable, fnm: PathOrStr, format: str, password: str = None) -> bool:\n        cargs = CancelEventArgs(Lo.store_doc_format.__qualname__)\n        cargs.event_data = {\n            "store": store,\n            "format": format,\n            "fnm": fnm,\n            "password": password,\n        }\n        _Events().trigger(LoNamedEvent.DOC_STORING, cargs)\n        if cargs.cancel:\n            return False\n        pth = mFileIO.FileIO.get_absolute_path(cargs.event_data["fnm"])\n        fmt = str(cargs.event_data["format"])\n        Lo.print(f"Saving the document in \'{pth}\'")\n        Lo.print(f"Using format {fmt}")\n        try:\n            save_file_url = mFileIO.FileIO.fnm_to_url(pth)\n            if password is None:\n                store_props = mProps.Props.make_props(Overwrite=True, FilterName=fmt)\n            else:\n                store_props = mProps.Props.make_props(Overwrite=True, FilterName=fmt, Password=password)\n            store.storeToURL(save_file_url, store_props)\n        except IOException as e:\n            raise Exception(f"Could not save \'{pth}\'") from e\n        _Events().trigger(LoNamedEvent.DOC_STORED, EventArgs.from_args(cargs))\n        return True\n    @overload\n    @classmethod\n    def close(cls, closeable: XCloseable) -> bool:\n        ...\n    @overload\n    @classmethod\n    def close(cls, closeable: XCloseable, deliver_ownership: bool) -> bool:\n        ...\n    @classmethod\n    def close(cls, closeable: XCloseable, deliver_ownership=False) -> bool:\n        cargs = CancelEventArgs(Lo.close.__qualname__)\n        cargs.event_data = deliver_ownership\n        _Events().trigger(LoNamedEvent.DOC_CLOSING, cargs)\n        if cargs.cancel:\n            return False\n        if closeable is None:\n            return\n        cls.print("Closing the document")\n        try:\n            closeable.close(cargs.event_data)\n            cls._doc = None\n            _Events().trigger(LoNamedEvent.DOC_CLOSED, EventArgs.from_args(cargs))\n        except CloseVetoException as e:\n            raise Exception("Close was vetoed") from e\n    @overload\n    @classmethod\n    def close_doc(cls, doc: object) -> None:\n        ...\n    @overload\n    @classmethod\n    def close_doc(cls, doc: object, deliver_ownership: bool) -> None:\n        ...\n    @classmethod\n    def close_doc(cls, doc: object, deliver_ownership=False) -> None:\n        try:\n            closeable = cls.qi(XCloseable, doc, True)\n            cls.close(closeable=closeable, deliver_ownership=deliver_ownership)\n            cls._doc = None\n        except DisposedException as e:\n            raise Exception("Document close failed since Office link disposed") from e\n    @classmethod\n    def addon_initialize(cls, addon_xcc: XComponentContext) -> XComponent:\n        cargs = CancelEventArgs(Lo.addon_initialize.__qualname__)\n        cargs.event_data = {"addon_xcc": addon_xcc}\n        eargs = EventArgs.from_args(cargs)\n        _Events().trigger(LoNamedEvent.RESET, eargs)\n        _Events().trigger(LoNamedEvent.DOC_OPENING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        xcc = addon_xcc\n        if xcc is None:\n            raise TypeError("\'addon_xcc\' is null. Could not access component context")\n        mc_factory = xcc.getServiceManager()\n        if mc_factory is None:\n            raise Exception("Office Service Manager is unavailable")\n        try:\n            xdesktop: XDesktop = mc_factory.createInstanceWithContext("com.sun.star.frame.Desktop", xcc)\n        except Exception:\n            raise Exception("Could not access desktop")\n        doc = xdesktop.getCurrentComponent()\n        if doc is None:\n            raise Exception("Could not access document")\n        cls._ms_factory = cls.qi(XMultiServiceFactory, doc)\n        if cls._ms_factory in None:\n            raise mEx.MissingInterfaceError(XMultiServiceFactory)\n        cls._doc = doc\n        _Events().trigger(LoNamedEvent.DOC_OPENED, eargs)\n        return doc\n    @classmethod\n    def script_initialize(cls, sc: XScriptContext) -> XComponent:\n        cargs = CancelEventArgs(Lo.script_initialize.__qualname__)\n        cargs.event_data = {"sc": sc}\n        eargs = EventArgs.from_args(cargs)\n        _Events().trigger(LoNamedEvent.RESET, eargs)\n        _Events().trigger(LoNamedEvent.DOC_OPENING, cargs)\n        if cargs.cancel:\n            raise mEx.CancelEventError(cargs)\n        if sc is None:\n            raise TypeError("Script Context is null")\n        xcc = sc.getComponentContext()\n        if xcc is None:\n            raise Exception("Could not access component context")\n        mc_factory = xcc.getServiceManager()\n        if mc_factory is None:\n            raise Exception("Office Service Manager is unavailable")\n        xdesktop = sc.getDesktop()\n        if xdesktop is None:\n            raise Exception("Could not access desktop")\n        doc = xdesktop.getCurrentComponent()\n        if doc is None:\n            raise Exception("Could not access document")\n        cls._ms_factory = cls.qi(XMultiServiceFactory, doc)\n        if cls._ms_factory in None:\n            raise mEx.MissingInterfaceError(XMultiServiceFactory)\n        cls._doc = doc\n        _Events().trigger(LoNamedEvent.DOC_OPENED, eargs)\n        return doc\n    @overload\n    @staticmethod\n    def dispatch_cmd(cmd: str) -> bool:\n        ...\n    @overload\n    @staticmethod\n    def dispatch_cmd(cmd: str, props: Iterable[PropertyValue]) -> bool:\n        ...\n    @overload\n    @staticmethod\n    def dispatch_cmd(cmd: str, props: Iterable[PropertyValue], frame: XFrame) -> bool:\n        ...\n    @classmethod\n    def dispatch_cmd(cls, cmd: str, props: Iterable[PropertyValue] = None, frame: XFrame = None) -> bool:\n        cargs = DispatchCancelArgs(Lo.dispatch_cmd.__qualname__, cmd)\n        _Events().trigger(LoNamedEvent.DISPATCHING, cargs)\n        if cargs.cancel:\n            return False\n        if props is None:\n            props = ()\n        if frame is None:\n            frame = cls._xdesktop.getCurrentFrame()\n        helper = cls.create_instance_mcf(XDispatchHelper, "com.sun.star.frame.DispatchHelper")\n        if helper is None:\n            raise mEx.MissingInterfaceError(XDispatchHelper, f"Could not create dispatch helper for command {cmd}")\n        try:\n            helper.executeDispatch(frame, f".uno:{cmd}", "", 0, props)\n            _Events().trigger(LoNamedEvent.DISPATCHED, DispatchArgs.from_args(cargs))\n            return True\n        except Exception as e:\n            raise Exception(f"Could not dispatch \'{cmd}\'") from e\n    @staticmethod\n    def make_uno_cmd(item_name: str) -> str:\n        return f"vnd.sun.star.script:Foo/Foo.{item_name}?language=Java&location=share"\n    @staticmethod\n    def extract_item_name(uno_cmd: str) -> str:\n        try:\n            foo_pos = uno_cmd.index("Foo.")\n        except ValueError:\n            raise ValueError(f"Could not find Foo header in command: \'{uno_cmd}\'")\n        try:\n            lang_pos = uno_cmd.index("?language")\n        except ValueError:\n            raise ValueError(f"Could not find language header in command: \'{uno_cmd}\'")\n        start = foo_pos + 4\n        return uno_cmd[start:lang_pos]\n    @classmethod\n    def inspect(cls, obj: object) -> None:\n        if cls._xcc is None or cls._mc_factory is None:\n            Lo.print("No office connection found")\n            return\n        try:\n            ts = mInfo.Info.get_interface_types(obj)\n            title = "Object"\n            if ts is not None and len(ts) > 0:\n                title = ts[0].getTypeName() + " " + title\n            inspector = cls._mc_factory.createInstanceWithContext("org.openoffice.InstanceInspector", cls._xcc)\n            if inspector is None:\n                Lo.print("Inspector Service could not be instantiated")\n                return\n            Lo.print("Inspector Service instantiated")\n            intro = cls.create_instance_mcf(XIntrospection, "com.sun.star.beans.Introspection")\n            intro_acc = intro.inspect(inspector)\n            method = intro_acc.getMethod("inspect", -1)\n            Lo.print(f"inspect() method was found: {method is not None}")\n            params = [[obj, title]]\n            method.invoke(inspector, params)\n        except Exception as e:\n            Lo.print("Could not access Inspector:")\n            Lo.print(f"    {e}")\n    @classmethod\n    def mri_inspect(cls, obj: object) -> None:\n        xi = cls.create_instance_mcf(XIntrospection, "mytools.Mri")\n        if xi is None:\n            raise Exception("MRI Inspector Service could not be instantiated")\n        Lo.print("MRI Inspector Service instantiated")\n        xi.inspect(obj)\n    @staticmethod\n    def delay(ms: int) -> None:\n        if ms <= 0:\n            Lo.print("Ms must be greater then zero")\n            return\n        sec = ms / 1000\n        time.sleep(sec)\n    wait = delay\n    @staticmethod\n    def is_none_or_empty(s: str) -> bool:\n        return s == None or len(s) == 0\n    is_null_or_empty = is_none_or_empty\n    @staticmethod\n    def wait_enter() -> None:\n        input("Press Enter to continue...")\n    @staticmethod\n    def is_url(fnm: PathOrStr) -> bool:\n        try:\n            pth = mFileIO.FileIO.get_absolute_path(fnm)\n            result = urlparse(str(pth))\n            return all([result.scheme, result.netloc])\n        except ValueError:\n            return False\n    @staticmethod\n    def capitalize(s: str) -> str:\n        return s.capitalize()\n    @staticmethod\n    def parse_int(s: str) -> int:\n        if s is None:\n            return 0\n        try:\n            return int(s)\n        except ValueError:\n            Lo.print(f"{s} could not be parsed as an int; using 0")\n        return 0\n    @overload\n    @staticmethod\n    def print_names(names: Iterable[str]) -> None:\n        ...\n    @overload\n    @staticmethod\n    def print_names(names: Iterable[str], num_per_line: int) -> None:\n        ...\n    @staticmethod\n    def print_names(names: Iterable[str], num_per_line: int = 4) -> None:\n        if names is None:\n            print("  No names found")\n            return\n        sorted_list = sorted(names, key=str.casefold)\n        print(f"No. of names: {len(sorted_list)}")\n        nl_count = 0\n        for name in sorted_list:\n            print(f"  \'{name}\'", end="")\n            if num_per_line <= 0:\n                print()\n                continue\n            nl_count += 1\n            if nl_count % num_per_line == 0:\n                print()\n                nl_count = 0\n        print("\\n\\n")\n    @staticmethod\n    def print_table(name: str, table: Iterable[Iterable[object]]) -> None:\n        print(f"-- {name} ----------------")\n        for row in table:\n            col_str = "  ".join([str(el) for el in row])\n            print(col_str)\n        print()\n    @staticmethod\n    def get_container_names(con: XIndexAccess) -> List[str] | None:\n        if con is None:\n            Lo.print("Container is null")\n            return None\n        num_el = con.getCount()\n        if num_el == 0:\n            Lo.print("No elements in the container")\n            return None\n        names_list = []\n        for i in range(num_el):\n            named = con.getByIndex(i)\n            names_list.append(named.getName())\n        if len(names_list) == 0:\n            Lo.print("No element names found in the container")\n            return None\n        return names_list\n    @classmethod\n    def find_container_props(cls, con: XIndexAccess, nm: str) -> XPropertySet | None:\n        if con is None:\n            raise TypeError("Container is null")\n        for i in range(con.getCount()):\n            try:\n                el = con.getByIndex(i)\n                named = cls.qi(XNamed, el)\n                if named and named.getName() == nm:\n                    return cls.qi(XPropertySet, el)\n            except Exception:\n                cls.print(f"Could not access element {i}")\n        cls.print(f"Could not find a \'{nm}\' property set in the container")\n        return None\n    @classmethod\n    def is_uno_interfaces(cls, component: object, *args: str | UnoInterface) -> bool:\n        if len(args) == 0:\n            return False\n        result = True\n        for arg in args:\n            try:\n                if isinstance(arg, str):\n                    t = uno.getClass(arg)\n                else:\n                    t = arg\n                obj = cls.qi(t, component)\n                if obj is None:\n                    result = False\n                    break\n            except Exception:\n                result = False\n                break\n        return result\n    @classmethod\n    def get_frame(cls) -> XFrame:\n        if cls.star_desktop is None:\n            raise Exception("No desktop found")\n        return cls.XSCRIPTCONTEXT.getDesktop().getCurrentFrame()\n    @classmethod\n    def get_model(cls) -> XModel:\n        return cls.XSCRIPTCONTEXT.getDocument()\n    @classmethod\n    def lock_controllers(cls) -> bool:\n        cargs = CancelEventArgs(Lo.lock_controllers.__qualname__)\n        _Events().trigger(LoNamedEvent.CONTROLERS_LOCKING, cargs)\n        if cargs.cancel:\n            return False\n        xmodel = cls.qi(XModel, cls._doc, True)\n        xmodel.lockControllers()\n        _Events().trigger(LoNamedEvent.CONTROLERS_LOCKED, EventArgs(cls))\n        return True\n    @classmethod\n    def unlock_controllers(cls) -> uno.Bool:\n        cargs = CancelEventArgs(Lo.unlock_controllers.__qualname__)\n        _Events().trigger(LoNamedEvent.CONTROLERS_UNLOCKING, cargs)\n        if cargs.cancel:\n            return False\n        xmodel = cls.qi(XModel, cls._doc, True)\n        if xmodel.hasControllersLocked():\n            xmodel.unlockControllers()\n        _Events().trigger(LoNamedEvent.CONTROLERS_UNLOCKED, EventArgs.from_args(cargs))\n        return True\n    @classmethod\n    def has_controllers_locked(cls) -> bool:\n        xmodel = cls.qi(XModel, cls._doc)\n        return xmodel.hasControllersLocked()\n    @staticmethod\n    def print(*args, **kwargs) -> None:\n        cargs = CancelEventArgs(Lo.print.__qualname__)\n        _Events().trigger(GblNamedEvent.PRINTING, cargs)\n        if cargs.cancel:\n            return\n        print(*args, **kwargs)\n    @classproperty\n    def null_date(cls) -> datetime:\n        try:\n            return cls.__null_date\n        except AttributeError:\n            cls.__null_date = datetime(year=1889, month=12, day=30, tzinfo=timezone.utc)\n            if cls._doc is None:\n                return cls.__null_date\n            n_supplier = cls.qi(XNumberFormatsSupplier, cls._doc)\n            if n_supplier is None:\n                return cls.__null_date\n            number_settings = n_supplier.getNumberFormatSettings()\n            d = number_settings.getPropertyValue("NullDate")\n            cls.__null_date = datetime(d.Year, d.Month, d.Day, tzinfo=timezone.utc)\n        return cls.__null_date\n    @null_date.setter\n    def null_date(cls, value) -> None:\n        raise AttributeError("Attempt to modify read-only class property \'%s\'." % cls.__name__)\n    @classproperty\n    def is_loaded(cls) -> bool:\n        return not cls._lo_inst is None\n    @is_loaded.setter\n    def is_loaded(cls, value) -> None:\n        raise AttributeError("Attempt to modify read-only class property \'%s\'." % cls.__name__)\n    @classproperty\n    def is_macro_mode(cls) -> bool:\n        try:\n            return cls._is_macro_mode\n        except AttributeError:\n            if cls._lo_inst is None:\n                return False\n            cls._is_macro_mode = isinstance(cls._lo_inst, LoDirectStart)\n        return cls._is_macro_mode\n    @is_macro_mode.setter\n    def is_macro_mode(cls, value) -> None:\n        raise AttributeError("Attempt to modify read-only class property \'%s\'." % cls.__name__)\n    @classproperty\n    def star_desktop(cls) -> XDesktop:\n        return cls._xdesktop\n    StarDesktop, stardesktop = star_desktop, star_desktop\n    @classproperty\n    def this_component(cls) -> XComponent:\n        try:\n            return cls._this_component\n        except AttributeError:\n            if mock_g.DOCS_BUILDING:\n                cls._this_component = None\n                return cls._this_component\n            if cls.is_loaded is False:\n                cls.load_office()\n            desktop = cls.get_desktop()\n            if desktop is None:\n                return None\n            if cls._doc is None:\n                cls._doc = desktop.getCurrentComponent()\n            if cls._doc is None:\n                return None\n            impl = cls._doc.ImplementationName\n            if impl in ("com.sun.star.comp.basic.BasicIDE", "com.sun.star.comp.sfx2.BackingComp"):\n                return None  \n            cls._this_component = cls._doc\n            return cls._this_component\n    ThisComponent, thiscomponent = this_component, this_component\n    @classproperty\n    def xscript_context(cls) -> XScriptContext:\n        try:\n            return cls._xscript_context\n        except AttributeError:\n            ctx = cls.get_context()\n            if ctx is None:\n                cls.load_office()\n                ctx = cls.get_context()\n            desktop = cls.get_desktop()\n            model = cls.qi(XModel, cls._doc)\n            cls._xscript_context = script_context.ScriptContext(ctx=ctx, desktop=desktop, doc=model)\n        return cls._xscript_context\n    XSCRIPTCONTEXT = xscript_context\n    @classproperty\n    def bridge(cls) -> XComponent:\n        try:\n            return cls._bridge_component\n        except AttributeError:\n            try:\n                cls._bridge_component = cls._lo_inst.bridge_component\n            except AttributeError:\n                cls._bridge_component = None\n            return cls._bridge_component\nclass _LoManager(metaclass=StaticProperty):\n    @staticmethod\n    def del_cache_attrs(source: object, event: EventArgs) -> None:\n        dattrs = ("_xscript_context", "_is_macro_mode", "_this_component", "_bridge_component", "__null_date")\n        for attr in dattrs:\n            if hasattr(Lo, attr):\n                delattr(Lo, attr)\n    @staticmethod\n    def disposing_bridge(src: XEventAdapter, event: EventObject) -> None:\n        _Events().trigger(LoNamedEvent.BRIDGE_DISPOSED, EventArgs(_LoManager.disposing_bridge.__qualname__))\n    @staticmethod\n    def on_disposed(source: Any, event: EventObject) -> None:\n        Lo.print("Office bridge has gone!!")\n        dattrs = ("_xcc", "_doc", "_mc_factory", "_ms_factory", "_lo_inst", "_xdesktop")\n        dvals = (None, None, None, None, None, None)\n        for attr, val in zip(dattrs, dvals):\n            setattr(Lo, attr, val)\n    @staticmethod\n    def on_loading(source: Any, event: CancelEventArgs) -> None:\n        try:\n            bridge = cast(XComponent, Lo._lo_inst.bridge_component)\n            bridge.removeEventListener(_LoManager.event_adapter)\n        except Exception:\n            pass\n    @staticmethod\n    def on_loaded(source: Any, event: EventObject) -> None:\n        if Lo.bridge is not None:\n            Lo.bridge.addEventListener(_LoManager.event_adapter)\n    @classproperty\n    def event_adapter(cls) -> XEventAdapter:\n        try:\n            return cls._event_adapter\n        except AttributeError:\n            bridge_listen = XEventAdapter()\n            bridge_listen.disposing = types.MethodType(cls.disposing_bridge, bridge_listen)\n            cls._event_adapter = bridge_listen\n        return cls._event_adapter\n_Events().on(LoNamedEvent.RESET, _LoManager.del_cache_attrs)\n_Events().on(LoNamedEvent.OFFICE_LOADING, _LoManager.on_loading)\n_Events().on(LoNamedEvent.OFFICE_LOADED, _LoManager.on_loaded)\n_Events().on(LoNamedEvent.BRIDGE_DISPOSED, _LoManager.on_disposed)\n__all__ = ("Lo",)\n')
    __scriptmerge_write_module('ooodev/mock/__init__.py', b'')
    __scriptmerge_write_module('ooodev/mock/mock_g.py', b'import os\nON_RTD = os.environ.get(\'READTHEDOCS\', None) == \'True\'\nLOCAL_DOCS_BUILDING = os.environ.get("DOCS_BUILDING", None) == "True"\nDOCS_BUILDING = ON_RTD or LOCAL_DOCS_BUILDING\n')
    __scriptmerge_write_module('ooodev/events/__init__.py', b'')
    __scriptmerge_write_module('ooodev/events/event_singleton.py', b'from __future__ import annotations\nfrom weakref import ref, ReferenceType\nfrom .args.event_args import EventArgs\nfrom typing import List, Dict\nfrom ..utils import type_var\nfrom ..proto import event_observer\nclass _Events(object):\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if not cls._instance:\n            cls._instance = super(_Events, cls).__new__(cls, *args, **kwargs)\n            cls._instance._callbacks = None\n            cls._instance._observers: List[ReferenceType[event_observer.EventObserver]] = None\n        return cls._instance\n    def on(self, event_name: str, callback: type_var.EventCallback):\n        if self._callbacks is None:\n            self._callbacks: Dict[str, List[ReferenceType[type_var.EventCallback]]] = {}\n        if event_name not in self._callbacks:\n            self._callbacks[event_name] = [ref(callback)]\n        else:\n            self._callbacks[event_name].append(ref(callback))\n    def trigger(self, event_name: str, event_args: EventArgs, *args, **kwargs) -> None:\n        if self._callbacks is not None and event_name in self._callbacks:\n            cleanup = None\n            for i, callback in enumerate(self._callbacks[event_name]):\n                if callback() is None:\n                    if cleanup is None:\n                        cleanup = []\n                    cleanup.append(i)\n                    continue\n                if event_args is not None:\n                    event_args._event_name = event_name\n                    if event_args.event_source is None:\n                        event_args._event_source = self\n                if callable(callback()):\n                    try:\n                        callback()(event_args.source, event_args, *args, **kwargs)\n                    except AttributeError:\n                        callback()(self, None)\n            if cleanup is not None and len(cleanup) > 0:\n                cleanup.reverse()\n                for i in cleanup:\n                    self._callbacks[event_name].pop(i)\n                if len(self._callbacks[event_name]) == 0:\n                    del self._callbacks[event_name]\n        self._update_observers(event_name, event_args)\n    def _update_observers(self, event_name: str, event_args: EventArgs) -> None:\n        if self._observers is not None:\n            cleanup = None\n            for i, observer in enumerate(self._observers):\n                if observer() is None:\n                    if cleanup is None:\n                        cleanup = []\n                    cleanup.append(i)\n                    continue\n                observer().trigger(event_name=event_name, event_args=event_args)\n            if cleanup is not None and len(cleanup) > 0:\n                cleanup.reverse()\n                for i in cleanup:\n                    self._observers.pop(i)\n    def add_observer(self, *args: event_observer.EventObserver) -> None:\n        if self._observers is None:\n            self._observers = []\n        for observer in args:\n            self._observers.append(ref(observer))\n')
    __scriptmerge_write_module('ooodev/events/args/__init__.py', b'')
    __scriptmerge_write_module('ooodev/events/args/event_args.py', b'from __future__ import annotations\nfrom typing import Any\nfrom abc import ABC\nclass AbstractEvent(ABC):\n    __slots__ = ()\n    def __init__(self, source: Any) -> None:\n        self.source = source\n        self._event_name = ""\n        self._event_source = None\n        self.event_data = None\n    source: Any\n    event_data: Any\n    @property\n    def event_name(self) -> str:\n        return self._event_name\n    @property\n    def event_source(self) -> Any | None:\n        return self._event_source\n    def __repr__(self) -> str:\n        return f"<{self.__class__.__name__}: {self.event_name}>"\nclass EventArgs(AbstractEvent):\n    __slots__ = ("source", "_event_name", "event_data", "_event_source")\n    @staticmethod\n    def from_args(args: EventArgs) -> EventArgs:\n        eargs = EventArgs(source=args.source)\n        eargs._event_name = args.event_name\n        eargs._event_source = args.event_source\n        eargs.event_data = args.event_data\n        return eargs\ne = EventArgs(None)\n')
    __scriptmerge_write_module('ooodev/utils/type_var.py', b'from __future__ import annotations\nfrom typing import Callable, Sequence, TypeVar, Union, Any, Tuple, List, Dict\nfrom os import PathLike\nimport uno\nfrom com.sun.star.text import XText\nfrom com.sun.star.text import XTextCursor\nfrom com.sun.star.text import XTextDocument\nfrom ..events.args import event_args\nPathOrStr = Union[str, PathLike]\nUnoInterface = object\nT = TypeVar("T")\nRow = Sequence[Any]\nDictRow = Dict[str, Any]\nDictTable = Sequence[DictRow]\nColumn = Sequence[Any]\nTable = Sequence[Row]\nTupleArray = Tuple[Tuple[Any, ...], ...]\nFloatList = List[float]\nFloatTable = List[FloatList]\nDocOrCursor = Union[XTextDocument, XTextCursor]\nDocOrText = Union[XTextDocument, XText]\nEventCallback = Callable[[object, event_args.EventArgs], None]\n')
    __scriptmerge_write_module('com/sun/star/__init__.py', b'from typing import TYPE_CHECKING\nif not TYPE_CHECKING:\n    raise ImportError\n')
    __scriptmerge_write_module('ooodev/proto/__init__.py', b'')
    __scriptmerge_write_module('ooodev/proto/event_observer.py', b'import sys\nif sys.version_info < (3, 8):\n    from typing_extensions import Protocol\nelse:\n    from typing import Protocol\nfrom ..utils import type_var\nfrom ..events.args import event_args\nclass EventObserver(Protocol):\n    def on(self, event_name: str, callback: type_var.EventCallback):\n        ...\n    def remove(self, event_name: str, callback: type_var.EventCallback) -> bool:\n        ...\n    def trigger(self, event_name: str, event_args: event_args.EventArgs):\n        ...\n')
    __scriptmerge_write_module('typing_extensions.py', b'import abc\nimport collections\nimport collections.abc\nimport functools\nimport operator\nimport sys\nimport types as _types\nimport typing\n__all__ = [\n    \'ClassVar\',\n    \'Concatenate\',\n    \'Final\',\n    \'LiteralString\',\n    \'ParamSpec\',\n    \'ParamSpecArgs\',\n    \'ParamSpecKwargs\',\n    \'Self\',\n    \'Type\',\n    \'TypeVarTuple\',\n    \'Unpack\',\n    \'Awaitable\',\n    \'AsyncIterator\',\n    \'AsyncIterable\',\n    \'Coroutine\',\n    \'AsyncGenerator\',\n    \'AsyncContextManager\',\n    \'ChainMap\',\n    \'ContextManager\',\n    \'Counter\',\n    \'Deque\',\n    \'DefaultDict\',\n    \'NamedTuple\',\n    \'OrderedDict\',\n    \'TypedDict\',\n    \'SupportsIndex\',\n    \'Annotated\',\n    \'assert_never\',\n    \'assert_type\',\n    \'clear_overloads\',\n    \'dataclass_transform\',\n    \'get_overloads\',\n    \'final\',\n    \'get_args\',\n    \'get_origin\',\n    \'get_type_hints\',\n    \'IntVar\',\n    \'is_typeddict\',\n    \'Literal\',\n    \'NewType\',\n    \'overload\',\n    \'Protocol\',\n    \'reveal_type\',\n    \'runtime\',\n    \'runtime_checkable\',\n    \'Text\',\n    \'TypeAlias\',\n    \'TypeGuard\',\n    \'TYPE_CHECKING\',\n    \'Never\',\n    \'NoReturn\',\n    \'Required\',\n    \'NotRequired\',\n]\nPEP_560 = True\nGenericMeta = type\n_marker = object()\ndef _check_generic(cls, parameters, elen=_marker):\n    if not elen:\n        raise TypeError(f"{cls} is not a generic class")\n    if elen is _marker:\n        if not hasattr(cls, "__parameters__") or not cls.__parameters__:\n            raise TypeError(f"{cls} is not a generic class")\n        elen = len(cls.__parameters__)\n    alen = len(parameters)\n    if alen != elen:\n        if hasattr(cls, "__parameters__"):\n            parameters = [p for p in cls.__parameters__ if not _is_unpack(p)]\n            num_tv_tuples = sum(isinstance(p, TypeVarTuple) for p in parameters)\n            if (num_tv_tuples > 0) and (alen >= elen - num_tv_tuples):\n                return\n        raise TypeError(f"Too {\'many\' if alen > elen else \'few\'} parameters for {cls};"\n                        f" actual {alen}, expected {elen}")\nif sys.version_info >= (3, 10):\n    def _should_collect_from_parameters(t):\n        return isinstance(\n            t, (typing._GenericAlias, _types.GenericAlias, _types.UnionType)\n        )\nelif sys.version_info >= (3, 9):\n    def _should_collect_from_parameters(t):\n        return isinstance(t, (typing._GenericAlias, _types.GenericAlias))\nelse:\n    def _should_collect_from_parameters(t):\n        return isinstance(t, typing._GenericAlias) and not t._special\ndef _collect_type_vars(types, typevar_types=None):\n    if typevar_types is None:\n        typevar_types = typing.TypeVar\n    tvars = []\n    for t in types:\n        if (\n            isinstance(t, typevar_types) and\n            t not in tvars and\n            not _is_unpack(t)\n        ):\n            tvars.append(t)\n        if _should_collect_from_parameters(t):\n            tvars.extend([t for t in t.__parameters__ if t not in tvars])\n    return tuple(tvars)\nNoReturn = typing.NoReturn\nT = typing.TypeVar(\'T\')  \nKT = typing.TypeVar(\'KT\')  \nVT = typing.TypeVar(\'VT\')  \nT_co = typing.TypeVar(\'T_co\', covariant=True)  \nT_contra = typing.TypeVar(\'T_contra\', contravariant=True)  \nClassVar = typing.ClassVar\nif hasattr(typing, \'Final\') and sys.version_info[:2] >= (3, 7):\n    Final = typing.Final\nelse:\n    class _FinalForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            item = typing._type_check(parameters,\n                                      f\'{self._name} accepts only a single type.\')\n            return typing._GenericAlias(self, (item,))\n    Final = _FinalForm(\'Final\',\n                       doc="""A special typing construct to indicate that a name\n                       cannot be re-assigned or overridden in a subclass.\n                       For example:\n                           MAX_SIZE: Final = 9000\n                           MAX_SIZE += 1  # Error reported by type checker\n                           class Connection:\n                               TIMEOUT: Final[int] = 10\n                           class FastConnector(Connection):\n                               TIMEOUT = 1  # Error reported by type checker\n                       There is no runtime checking of these properties.""")\nif sys.version_info >= (3, 11):\n    final = typing.final\nelse:\n    def final(f):\n        try:\n            f.__final__ = True\n        except (AttributeError, TypeError):\n            pass\n        return f\ndef IntVar(name):\n    return typing.TypeVar(name)\nif hasattr(typing, \'Literal\'):\n    Literal = typing.Literal\nelse:\n    class _LiteralForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            return typing._GenericAlias(self, parameters)\n    Literal = _LiteralForm(\'Literal\',\n                           doc="""A type that can be used to indicate to type checkers\n                           that the corresponding value has a value literally equivalent\n                           to the provided parameter. For example:\n                               var: Literal[4] = 4\n                           The type checker understands that \'var\' is literally equal to\n                           the value 4 and no other value.\n                           Literal[...] cannot be subclassed. There is no runtime\n                           checking verifying that the parameter is actually a value\n                           instead of a type.""")\n_overload_dummy = typing._overload_dummy  \nif hasattr(typing, "get_overloads"):  \n    overload = typing.overload\n    get_overloads = typing.get_overloads\n    clear_overloads = typing.clear_overloads\nelse:\n    _overload_registry = collections.defaultdict(\n        functools.partial(collections.defaultdict, dict)\n    )\n    def overload(func):\n        f = getattr(func, "__func__", func)\n        try:\n            _overload_registry[f.__module__][f.__qualname__][\n                f.__code__.co_firstlineno\n            ] = func\n        except AttributeError:\n            pass\n        return _overload_dummy\n    def get_overloads(func):\n        f = getattr(func, "__func__", func)\n        if f.__module__ not in _overload_registry:\n            return []\n        mod_dict = _overload_registry[f.__module__]\n        if f.__qualname__ not in mod_dict:\n            return []\n        return list(mod_dict[f.__qualname__].values())\n    def clear_overloads():\n        _overload_registry.clear()\nType = typing.Type\nAwaitable = typing.Awaitable\nCoroutine = typing.Coroutine\nAsyncIterable = typing.AsyncIterable\nAsyncIterator = typing.AsyncIterator\nDeque = typing.Deque\nContextManager = typing.ContextManager\nAsyncContextManager = typing.AsyncContextManager\nDefaultDict = typing.DefaultDict\nif hasattr(typing, \'OrderedDict\'):\n    OrderedDict = typing.OrderedDict\nelse:\n    OrderedDict = typing._alias(collections.OrderedDict, (KT, VT))\nCounter = typing.Counter\nChainMap = typing.ChainMap\nAsyncGenerator = typing.AsyncGenerator\nNewType = typing.NewType\nText = typing.Text\nTYPE_CHECKING = typing.TYPE_CHECKING\n_PROTO_WHITELIST = [\'Callable\', \'Awaitable\',\n                    \'Iterable\', \'Iterator\', \'AsyncIterable\', \'AsyncIterator\',\n                    \'Hashable\', \'Sized\', \'Container\', \'Collection\', \'Reversible\',\n                    \'ContextManager\', \'AsyncContextManager\']\ndef _get_protocol_attrs(cls):\n    attrs = set()\n    for base in cls.__mro__[:-1]:  \n        if base.__name__ in (\'Protocol\', \'Generic\'):\n            continue\n        annotations = getattr(base, \'__annotations__\', {})\n        for attr in list(base.__dict__.keys()) + list(annotations.keys()):\n            if (not attr.startswith(\'_abc_\') and attr not in (\n                    \'__abstractmethods__\', \'__annotations__\', \'__weakref__\',\n                    \'_is_protocol\', \'_is_runtime_protocol\', \'__dict__\',\n                    \'__args__\', \'__slots__\',\n                    \'__next_in_mro__\', \'__parameters__\', \'__origin__\',\n                    \'__orig_bases__\', \'__extra__\', \'__tree_hash__\',\n                    \'__doc__\', \'__subclasshook__\', \'__init__\', \'__new__\',\n                    \'__module__\', \'_MutableMapping__marker\', \'_gorg\')):\n                attrs.add(attr)\n    return attrs\ndef _is_callable_members_only(cls):\n    return all(callable(getattr(cls, attr, None)) for attr in _get_protocol_attrs(cls))\ndef _maybe_adjust_parameters(cls):\n    tvars = []\n    if \'__orig_bases__\' in cls.__dict__:\n        tvars = typing._collect_type_vars(cls.__orig_bases__)\n        gvars = None\n        for base in cls.__orig_bases__:\n            if (isinstance(base, typing._GenericAlias) and\n                    base.__origin__ in (typing.Generic, Protocol)):\n                the_base = base.__origin__.__name__\n                if gvars is not None:\n                    raise TypeError(\n                        "Cannot inherit from Generic[...]"\n                        " and/or Protocol[...] multiple types.")\n                gvars = base.__parameters__\n        if gvars is None:\n            gvars = tvars\n        else:\n            tvarset = set(tvars)\n            gvarset = set(gvars)\n            if not tvarset <= gvarset:\n                s_vars = \', \'.join(str(t) for t in tvars if t not in gvarset)\n                s_args = \', \'.join(str(g) for g in gvars)\n                raise TypeError(f"Some type variables ({s_vars}) are"\n                                f" not listed in {the_base}[{s_args}]")\n            tvars = gvars\n    cls.__parameters__ = tuple(tvars)\nif hasattr(typing, \'Protocol\'):\n    Protocol = typing.Protocol\nelse:\n    def _no_init(self, *args, **kwargs):\n        if type(self)._is_protocol:\n            raise TypeError(\'Protocols cannot be instantiated\')\n    class _ProtocolMeta(abc.ABCMeta):\n        def __instancecheck__(cls, instance):\n            if ((not getattr(cls, \'_is_protocol\', False) or\n                 _is_callable_members_only(cls)) and\n                    issubclass(instance.__class__, cls)):\n                return True\n            if cls._is_protocol:\n                if all(hasattr(instance, attr) and\n                       (not callable(getattr(cls, attr, None)) or\n                        getattr(instance, attr) is not None)\n                       for attr in _get_protocol_attrs(cls)):\n                    return True\n            return super().__instancecheck__(instance)\n    class Protocol(metaclass=_ProtocolMeta):\n        __slots__ = ()\n        _is_protocol = True\n        def __new__(cls, *args, **kwds):\n            if cls is Protocol:\n                raise TypeError("Type Protocol cannot be instantiated; "\n                                "it can only be used as a base class")\n            return super().__new__(cls)\n        @typing._tp_cache\n        def __class_getitem__(cls, params):\n            if not isinstance(params, tuple):\n                params = (params,)\n            if not params and cls is not typing.Tuple:\n                raise TypeError(\n                    f"Parameter list to {cls.__qualname__}[...] cannot be empty")\n            msg = "Parameters to generic types must be types."\n            params = tuple(typing._type_check(p, msg) for p in params)  \n            if cls is Protocol:\n                if not all(isinstance(p, typing.TypeVar) for p in params):\n                    i = 0\n                    while isinstance(params[i], typing.TypeVar):\n                        i += 1\n                    raise TypeError(\n                        "Parameters to Protocol[...] must all be type variables."\n                        f" Parameter {i + 1} is {params[i]}")\n                if len(set(params)) != len(params):\n                    raise TypeError(\n                        "Parameters to Protocol[...] must all be unique")\n            else:\n                _check_generic(cls, params, len(cls.__parameters__))\n            return typing._GenericAlias(cls, params)\n        def __init_subclass__(cls, *args, **kwargs):\n            if \'__orig_bases__\' in cls.__dict__:\n                error = typing.Generic in cls.__orig_bases__\n            else:\n                error = typing.Generic in cls.__bases__\n            if error:\n                raise TypeError("Cannot inherit from plain Generic")\n            _maybe_adjust_parameters(cls)\n            if not cls.__dict__.get(\'_is_protocol\', None):\n                cls._is_protocol = any(b is Protocol for b in cls.__bases__)\n            def _proto_hook(other):\n                if not cls.__dict__.get(\'_is_protocol\', None):\n                    return NotImplemented\n                if not getattr(cls, \'_is_runtime_protocol\', False):\n                    if sys._getframe(2).f_globals[\'__name__\'] in [\'abc\', \'functools\']:\n                        return NotImplemented\n                    raise TypeError("Instance and class checks can only be used with"\n                                    " @runtime protocols")\n                if not _is_callable_members_only(cls):\n                    if sys._getframe(2).f_globals[\'__name__\'] in [\'abc\', \'functools\']:\n                        return NotImplemented\n                    raise TypeError("Protocols with non-method members"\n                                    " don\'t support issubclass()")\n                if not isinstance(other, type):\n                    raise TypeError(\'issubclass() arg 1 must be a class\')\n                for attr in _get_protocol_attrs(cls):\n                    for base in other.__mro__:\n                        if attr in base.__dict__:\n                            if base.__dict__[attr] is None:\n                                return NotImplemented\n                            break\n                        annotations = getattr(base, \'__annotations__\', {})\n                        if (isinstance(annotations, typing.Mapping) and\n                                attr in annotations and\n                                isinstance(other, _ProtocolMeta) and\n                                other._is_protocol):\n                            break\n                    else:\n                        return NotImplemented\n                return True\n            if \'__subclasshook__\' not in cls.__dict__:\n                cls.__subclasshook__ = _proto_hook\n            if not cls._is_protocol:\n                return\n            for base in cls.__bases__:\n                if not (base in (object, typing.Generic) or\n                        base.__module__ == \'collections.abc\' and\n                        base.__name__ in _PROTO_WHITELIST or\n                        isinstance(base, _ProtocolMeta) and base._is_protocol):\n                    raise TypeError(\'Protocols can only inherit from other\'\n                                    f\' protocols, got {repr(base)}\')\n            cls.__init__ = _no_init\nif hasattr(typing, \'runtime_checkable\'):\n    runtime_checkable = typing.runtime_checkable\nelse:\n    def runtime_checkable(cls):\n        if not isinstance(cls, _ProtocolMeta) or not cls._is_protocol:\n            raise TypeError(\'@runtime_checkable can be only applied to protocol classes,\'\n                            f\' got {cls!r}\')\n        cls._is_runtime_protocol = True\n        return cls\nruntime = runtime_checkable\nif hasattr(typing, \'SupportsIndex\'):\n    SupportsIndex = typing.SupportsIndex\nelse:\n    @runtime_checkable\n    class SupportsIndex(Protocol):\n        __slots__ = ()\n        @abc.abstractmethod\n        def __index__(self) -> int:\n            pass\nif hasattr(typing, "Required"):\n    TypedDict = typing.TypedDict\n    _TypedDictMeta = typing._TypedDictMeta\n    is_typeddict = typing.is_typeddict\nelse:\n    def _check_fails(cls, other):\n        try:\n            if sys._getframe(1).f_globals[\'__name__\'] not in [\'abc\',\n                                                              \'functools\',\n                                                              \'typing\']:\n                raise TypeError(\'TypedDict does not support instance and class checks\')\n        except (AttributeError, ValueError):\n            pass\n        return False\n    def _dict_new(*args, **kwargs):\n        if not args:\n            raise TypeError(\'TypedDict.__new__(): not enough arguments\')\n        _, args = args[0], args[1:]  \n        return dict(*args, **kwargs)\n    _dict_new.__text_signature__ = \'($cls, _typename, _fields=None, /, **kwargs)\'\n    def _typeddict_new(*args, total=True, **kwargs):\n        if not args:\n            raise TypeError(\'TypedDict.__new__(): not enough arguments\')\n        _, args = args[0], args[1:]  \n        if args:\n            typename, args = args[0], args[1:]  \n        elif \'_typename\' in kwargs:\n            typename = kwargs.pop(\'_typename\')\n            import warnings\n            warnings.warn("Passing \'_typename\' as keyword argument is deprecated",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            raise TypeError("TypedDict.__new__() missing 1 required positional "\n                            "argument: \'_typename\'")\n        if args:\n            try:\n                fields, = args  \n            except ValueError:\n                raise TypeError(\'TypedDict.__new__() takes from 2 to 3 \'\n                                f\'positional arguments but {len(args) + 2} \'\n                                \'were given\')\n        elif \'_fields\' in kwargs and len(kwargs) == 1:\n            fields = kwargs.pop(\'_fields\')\n            import warnings\n            warnings.warn("Passing \'_fields\' as keyword argument is deprecated",\n                          DeprecationWarning, stacklevel=2)\n        else:\n            fields = None\n        if fields is None:\n            fields = kwargs\n        elif kwargs:\n            raise TypeError("TypedDict takes either a dict or keyword arguments,"\n                            " but not both")\n        ns = {\'__annotations__\': dict(fields)}\n        try:\n            ns[\'__module__\'] = sys._getframe(1).f_globals.get(\'__name__\', \'__main__\')\n        except (AttributeError, ValueError):\n            pass\n        return _TypedDictMeta(typename, (), ns, total=total)\n    _typeddict_new.__text_signature__ = (\'($cls, _typename, _fields=None,\'\n                                         \' /, *, total=True, **kwargs)\')\n    class _TypedDictMeta(type):\n        def __init__(cls, name, bases, ns, total=True):\n            super().__init__(name, bases, ns)\n        def __new__(cls, name, bases, ns, total=True):\n            ns[\'__new__\'] = _typeddict_new if name == \'TypedDict\' else _dict_new\n            tp_dict = super().__new__(cls, name, (dict,), ns)\n            if any(issubclass(base, typing.Generic) for base in bases):\n                tp_dict.__bases__ = (typing.Generic, dict)\n                _maybe_adjust_parameters(tp_dict)\n            annotations = {}\n            own_annotations = ns.get(\'__annotations__\', {})\n            msg = "TypedDict(\'Name\', {f0: t0, f1: t1, ...}); each t must be a type"\n            own_annotations = {\n                n: typing._type_check(tp, msg) for n, tp in own_annotations.items()\n            }\n            required_keys = set()\n            optional_keys = set()\n            for base in bases:\n                annotations.update(base.__dict__.get(\'__annotations__\', {}))\n                required_keys.update(base.__dict__.get(\'__required_keys__\', ()))\n                optional_keys.update(base.__dict__.get(\'__optional_keys__\', ()))\n            annotations.update(own_annotations)\n            for annotation_key, annotation_type in own_annotations.items():\n                annotation_origin = get_origin(annotation_type)\n                if annotation_origin is Annotated:\n                    annotation_args = get_args(annotation_type)\n                    if annotation_args:\n                        annotation_type = annotation_args[0]\n                        annotation_origin = get_origin(annotation_type)\n                if annotation_origin is Required:\n                    required_keys.add(annotation_key)\n                elif annotation_origin is NotRequired:\n                    optional_keys.add(annotation_key)\n                elif total:\n                    required_keys.add(annotation_key)\n                else:\n                    optional_keys.add(annotation_key)\n            tp_dict.__annotations__ = annotations\n            tp_dict.__required_keys__ = frozenset(required_keys)\n            tp_dict.__optional_keys__ = frozenset(optional_keys)\n            if not hasattr(tp_dict, \'__total__\'):\n                tp_dict.__total__ = total\n            return tp_dict\n        __instancecheck__ = __subclasscheck__ = _check_fails\n    TypedDict = _TypedDictMeta(\'TypedDict\', (dict,), {})\n    TypedDict.__module__ = __name__\n    TypedDict.__doc__ =        """A simple typed name space. At runtime it is equivalent to a plain dict.\n        TypedDict creates a dictionary type that expects all of its\n        instances to have a certain set of keys, with each key\n        associated with a value of a consistent type. This expectation\n        is not checked at runtime but is only enforced by type checkers.\n        Usage::\n            class Point2D(TypedDict):\n                x: int\n                y: int\n                label: str\n            a: Point2D = {\'x\': 1, \'y\': 2, \'label\': \'good\'}  # OK\n            b: Point2D = {\'z\': 3, \'label\': \'bad\'}           # Fails type check\n            assert Point2D(x=1, y=2, label=\'first\') == dict(x=1, y=2, label=\'first\')\n        The type info can be accessed via the Point2D.__annotations__ dict, and\n        the Point2D.__required_keys__ and Point2D.__optional_keys__ frozensets.\n        TypedDict supports two additional equivalent forms::\n            Point2D = TypedDict(\'Point2D\', x=int, y=int, label=str)\n            Point2D = TypedDict(\'Point2D\', {\'x\': int, \'y\': int, \'label\': str})\n        The class syntax is only supported in Python 3.6+, while two other\n        syntax forms work for Python 2.7 and 3.2+\n        """\n    if hasattr(typing, "_TypedDictMeta"):\n        _TYPEDDICT_TYPES = (typing._TypedDictMeta, _TypedDictMeta)\n    else:\n        _TYPEDDICT_TYPES = (_TypedDictMeta,)\n    def is_typeddict(tp):\n        return isinstance(tp, tuple(_TYPEDDICT_TYPES))\nif hasattr(typing, "assert_type"):\n    assert_type = typing.assert_type\nelse:\n    def assert_type(__val, __typ):\n        return __val\nif hasattr(typing, "Required"):\n    get_type_hints = typing.get_type_hints\nelse:\n    import functools\n    import types\n    def _strip_extras(t):\n        if isinstance(t, _AnnotatedAlias):\n            return _strip_extras(t.__origin__)\n        if hasattr(t, "__origin__") and t.__origin__ in (Required, NotRequired):\n            return _strip_extras(t.__args__[0])\n        if isinstance(t, typing._GenericAlias):\n            stripped_args = tuple(_strip_extras(a) for a in t.__args__)\n            if stripped_args == t.__args__:\n                return t\n            return t.copy_with(stripped_args)\n        if hasattr(types, "GenericAlias") and isinstance(t, types.GenericAlias):\n            stripped_args = tuple(_strip_extras(a) for a in t.__args__)\n            if stripped_args == t.__args__:\n                return t\n            return types.GenericAlias(t.__origin__, stripped_args)\n        if hasattr(types, "UnionType") and isinstance(t, types.UnionType):\n            stripped_args = tuple(_strip_extras(a) for a in t.__args__)\n            if stripped_args == t.__args__:\n                return t\n            return functools.reduce(operator.or_, stripped_args)\n        return t\n    def get_type_hints(obj, globalns=None, localns=None, include_extras=False):\n        if hasattr(typing, "Annotated"):\n            hint = typing.get_type_hints(\n                obj, globalns=globalns, localns=localns, include_extras=True\n            )\n        else:\n            hint = typing.get_type_hints(obj, globalns=globalns, localns=localns)\n        if include_extras:\n            return hint\n        return {k: _strip_extras(t) for k, t in hint.items()}\nif hasattr(typing, \'Annotated\'):\n    Annotated = typing.Annotated\n    _AnnotatedAlias = typing._AnnotatedAlias\nelse:\n    class _AnnotatedAlias(typing._GenericAlias, _root=True):\n        def __init__(self, origin, metadata):\n            if isinstance(origin, _AnnotatedAlias):\n                metadata = origin.__metadata__ + metadata\n                origin = origin.__origin__\n            super().__init__(origin, origin)\n            self.__metadata__ = metadata\n        def copy_with(self, params):\n            assert len(params) == 1\n            new_type = params[0]\n            return _AnnotatedAlias(new_type, self.__metadata__)\n        def __repr__(self):\n            return (f"typing_extensions.Annotated[{typing._type_repr(self.__origin__)}, "\n                    f"{\', \'.join(repr(a) for a in self.__metadata__)}]")\n        def __reduce__(self):\n            return operator.getitem, (\n                Annotated, (self.__origin__,) + self.__metadata__\n            )\n        def __eq__(self, other):\n            if not isinstance(other, _AnnotatedAlias):\n                return NotImplemented\n            if self.__origin__ != other.__origin__:\n                return False\n            return self.__metadata__ == other.__metadata__\n        def __hash__(self):\n            return hash((self.__origin__, self.__metadata__))\n    class Annotated:\n        __slots__ = ()\n        def __new__(cls, *args, **kwargs):\n            raise TypeError("Type Annotated cannot be instantiated.")\n        @typing._tp_cache\n        def __class_getitem__(cls, params):\n            if not isinstance(params, tuple) or len(params) < 2:\n                raise TypeError("Annotated[...] should be used "\n                                "with at least two arguments (a type and an "\n                                "annotation).")\n            allowed_special_forms = (ClassVar, Final)\n            if get_origin(params[0]) in allowed_special_forms:\n                origin = params[0]\n            else:\n                msg = "Annotated[t, ...]: t must be a type."\n                origin = typing._type_check(params[0], msg)\n            metadata = tuple(params[1:])\n            return _AnnotatedAlias(origin, metadata)\n        def __init_subclass__(cls, *args, **kwargs):\n            raise TypeError(\n                f"Cannot subclass {cls.__module__}.Annotated"\n            )\nif sys.version_info[:2] >= (3, 10):\n    get_origin = typing.get_origin\n    get_args = typing.get_args\nelse:\n    try:\n        from typing import _BaseGenericAlias\n    except ImportError:\n        _BaseGenericAlias = typing._GenericAlias\n    try:\n        from typing import GenericAlias as _typing_GenericAlias\n    except ImportError:\n        _typing_GenericAlias = typing._GenericAlias\n    def get_origin(tp):\n        if isinstance(tp, _AnnotatedAlias):\n            return Annotated\n        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias, _BaseGenericAlias,\n                           ParamSpecArgs, ParamSpecKwargs)):\n            return tp.__origin__\n        if tp is typing.Generic:\n            return typing.Generic\n        return None\n    def get_args(tp):\n        if isinstance(tp, _AnnotatedAlias):\n            return (tp.__origin__,) + tp.__metadata__\n        if isinstance(tp, (typing._GenericAlias, _typing_GenericAlias)):\n            if getattr(tp, "_special", False):\n                return ()\n            res = tp.__args__\n            if get_origin(tp) is collections.abc.Callable and res[0] is not Ellipsis:\n                res = (list(res[:-1]), res[-1])\n            return res\n        return ()\nif hasattr(typing, \'TypeAlias\'):\n    TypeAlias = typing.TypeAlias\nelif sys.version_info[:2] >= (3, 9):\n    class _TypeAliasForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n    @_TypeAliasForm\n    def TypeAlias(self, parameters):\n        raise TypeError(f"{self} is not subscriptable")\nelse:\n    class _TypeAliasForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n    TypeAlias = _TypeAliasForm(\'TypeAlias\',\n                               doc="""Special marker indicating that an assignment should\n                               be recognized as a proper type alias definition by type\n                               checkers.\n                               For example::\n                                   Predicate: TypeAlias = Callable[..., bool]\n                               It\'s invalid when used anywhere except as in the example\n                               above.""")\nif hasattr(typing, \'ParamSpecArgs\'):\n    ParamSpecArgs = typing.ParamSpecArgs\n    ParamSpecKwargs = typing.ParamSpecKwargs\nelse:\n    class _Immutable:\n        __slots__ = ()\n        def __copy__(self):\n            return self\n        def __deepcopy__(self, memo):\n            return self\n    class ParamSpecArgs(_Immutable):\n        def __init__(self, origin):\n            self.__origin__ = origin\n        def __repr__(self):\n            return f"{self.__origin__.__name__}.args"\n        def __eq__(self, other):\n            if not isinstance(other, ParamSpecArgs):\n                return NotImplemented\n            return self.__origin__ == other.__origin__\n    class ParamSpecKwargs(_Immutable):\n        def __init__(self, origin):\n            self.__origin__ = origin\n        def __repr__(self):\n            return f"{self.__origin__.__name__}.kwargs"\n        def __eq__(self, other):\n            if not isinstance(other, ParamSpecKwargs):\n                return NotImplemented\n            return self.__origin__ == other.__origin__\nif hasattr(typing, \'ParamSpec\'):\n    ParamSpec = typing.ParamSpec\nelse:\n    class ParamSpec(list):\n        __class__ = typing.TypeVar\n        @property\n        def args(self):\n            return ParamSpecArgs(self)\n        @property\n        def kwargs(self):\n            return ParamSpecKwargs(self)\n        def __init__(self, name, *, bound=None, covariant=False, contravariant=False):\n            super().__init__([self])\n            self.__name__ = name\n            self.__covariant__ = bool(covariant)\n            self.__contravariant__ = bool(contravariant)\n            if bound:\n                self.__bound__ = typing._type_check(bound, \'Bound must be a type.\')\n            else:\n                self.__bound__ = None\n            try:\n                def_mod = sys._getframe(1).f_globals.get(\'__name__\', \'__main__\')\n            except (AttributeError, ValueError):\n                def_mod = None\n            if def_mod != \'typing_extensions\':\n                self.__module__ = def_mod\n        def __repr__(self):\n            if self.__covariant__:\n                prefix = \'+\'\n            elif self.__contravariant__:\n                prefix = \'-\'\n            else:\n                prefix = \'~\'\n            return prefix + self.__name__\n        def __hash__(self):\n            return object.__hash__(self)\n        def __eq__(self, other):\n            return self is other\n        def __reduce__(self):\n            return self.__name__\n        def __call__(self, *args, **kwargs):\n            pass\nif not hasattr(typing, \'Concatenate\'):\n    class _ConcatenateGenericAlias(list):\n        __class__ = typing._GenericAlias\n        _special = False\n        def __init__(self, origin, args):\n            super().__init__(args)\n            self.__origin__ = origin\n            self.__args__ = args\n        def __repr__(self):\n            _type_repr = typing._type_repr\n            return (f\'{_type_repr(self.__origin__)}\'\n                    f\'[{", ".join(_type_repr(arg) for arg in self.__args__)}]\')\n        def __hash__(self):\n            return hash((self.__origin__, self.__args__))\n        def __call__(self, *args, **kwargs):\n            pass\n        @property\n        def __parameters__(self):\n            return tuple(\n                tp for tp in self.__args__ if isinstance(tp, (typing.TypeVar, ParamSpec))\n            )\n@typing._tp_cache\ndef _concatenate_getitem(self, parameters):\n    if parameters == ():\n        raise TypeError("Cannot take a Concatenate of no types.")\n    if not isinstance(parameters, tuple):\n        parameters = (parameters,)\n    if not isinstance(parameters[-1], ParamSpec):\n        raise TypeError("The last parameter to Concatenate should be a "\n                        "ParamSpec variable.")\n    msg = "Concatenate[arg, ...]: each arg must be a type."\n    parameters = tuple(typing._type_check(p, msg) for p in parameters)\n    return _ConcatenateGenericAlias(self, parameters)\nif hasattr(typing, \'Concatenate\'):\n    Concatenate = typing.Concatenate\n    _ConcatenateGenericAlias = typing._ConcatenateGenericAlias \nelif sys.version_info[:2] >= (3, 9):\n    @_TypeAliasForm\n    def Concatenate(self, parameters):\n        return _concatenate_getitem(self, parameters)\nelse:\n    class _ConcatenateForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            return _concatenate_getitem(self, parameters)\n    Concatenate = _ConcatenateForm(\n        \'Concatenate\',\n        doc="""Used in conjunction with ``ParamSpec`` and ``Callable`` to represent a\n        higher order function which adds, removes or transforms parameters of a\n        callable.\n        For example::\n           Callable[Concatenate[int, P], int]\n        See PEP 612 for detailed information.\n        """)\nif hasattr(typing, \'TypeGuard\'):\n    TypeGuard = typing.TypeGuard\nelif sys.version_info[:2] >= (3, 9):\n    class _TypeGuardForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n    @_TypeGuardForm\n    def TypeGuard(self, parameters):\n        item = typing._type_check(parameters, f\'{self} accepts only a single type.\')\n        return typing._GenericAlias(self, (item,))\nelse:\n    class _TypeGuardForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            item = typing._type_check(parameters,\n                                      f\'{self._name} accepts only a single type\')\n            return typing._GenericAlias(self, (item,))\n    TypeGuard = _TypeGuardForm(\n        \'TypeGuard\',\n        doc="""Special typing form used to annotate the return type of a user-defined\n        type guard function.  ``TypeGuard`` only accepts a single type argument.\n        At runtime, functions marked this way should return a boolean.\n        ``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static\n        type checkers to determine a more precise type of an expression within a\n        program\'s code flow.  Usually type narrowing is done by analyzing\n        conditional code flow and applying the narrowing to a block of code.  The\n        conditional expression here is sometimes referred to as a "type guard".\n        Sometimes it would be convenient to use a user-defined boolean function\n        as a type guard.  Such a function should use ``TypeGuard[...]`` as its\n        return type to alert static type checkers to this intention.\n        Using  ``-> TypeGuard`` tells the static type checker that for a given\n        function:\n        1. The return value is a boolean.\n        2. If the return value is ``True``, the type of its argument\n        is the type inside ``TypeGuard``.\n        For example::\n            def is_str(val: Union[str, float]):\n                # "isinstance" type guard\n                if isinstance(val, str):\n                    # Type of ``val`` is narrowed to ``str``\n                    ...\n                else:\n                    # Else, type of ``val`` is narrowed to ``float``.\n                    ...\n        Strict type narrowing is not enforced -- ``TypeB`` need not be a narrower\n        form of ``TypeA`` (it can even be a wider form) and this may lead to\n        type-unsafe results.  The main reason is to allow for things like\n        narrowing ``List[object]`` to ``List[str]`` even though the latter is not\n        a subtype of the former, since ``List`` is invariant.  The responsibility of\n        writing type-safe type guards is left to the user.\n        ``TypeGuard`` also works with type variables.  For more information, see\n        PEP 647 (User-Defined Type Guards).\n        """)\nclass _SpecialForm(typing._Final, _root=True):\n    __slots__ = (\'_name\', \'__doc__\', \'_getitem\')\n    def __init__(self, getitem):\n        self._getitem = getitem\n        self._name = getitem.__name__\n        self.__doc__ = getitem.__doc__\n    def __getattr__(self, item):\n        if item in {\'__name__\', \'__qualname__\'}:\n            return self._name\n        raise AttributeError(item)\n    def __mro_entries__(self, bases):\n        raise TypeError(f"Cannot subclass {self!r}")\n    def __repr__(self):\n        return f\'typing_extensions.{self._name}\'\n    def __reduce__(self):\n        return self._name\n    def __call__(self, *args, **kwds):\n        raise TypeError(f"Cannot instantiate {self!r}")\n    def __or__(self, other):\n        return typing.Union[self, other]\n    def __ror__(self, other):\n        return typing.Union[other, self]\n    def __instancecheck__(self, obj):\n        raise TypeError(f"{self} cannot be used with isinstance()")\n    def __subclasscheck__(self, cls):\n        raise TypeError(f"{self} cannot be used with issubclass()")\n    @typing._tp_cache\n    def __getitem__(self, parameters):\n        return self._getitem(self, parameters)\nif hasattr(typing, "LiteralString"):\n    LiteralString = typing.LiteralString\nelse:\n    @_SpecialForm\n    def LiteralString(self, params):\n        raise TypeError(f"{self} is not subscriptable")\nif hasattr(typing, "Self"):\n    Self = typing.Self\nelse:\n    @_SpecialForm\n    def Self(self, params):\n        raise TypeError(f"{self} is not subscriptable")\nif hasattr(typing, "Never"):\n    Never = typing.Never\nelse:\n    @_SpecialForm\n    def Never(self, params):\n        raise TypeError(f"{self} is not subscriptable")\nif hasattr(typing, \'Required\'):\n    Required = typing.Required\n    NotRequired = typing.NotRequired\nelif sys.version_info[:2] >= (3, 9):\n    class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n    @_ExtensionsSpecialForm\n    def Required(self, parameters):\n        item = typing._type_check(parameters, f\'{self._name} accepts only a single type.\')\n        return typing._GenericAlias(self, (item,))\n    @_ExtensionsSpecialForm\n    def NotRequired(self, parameters):\n        item = typing._type_check(parameters, f\'{self._name} accepts only a single type.\')\n        return typing._GenericAlias(self, (item,))\nelse:\n    class _RequiredForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            item = typing._type_check(parameters,\n                                      f\'{self._name} accepts only a single type.\')\n            return typing._GenericAlias(self, (item,))\n    Required = _RequiredForm(\n        \'Required\',\n        doc="""A special typing construct to mark a key of a total=False TypedDict\n        as required. For example:\n            class Movie(TypedDict, total=False):\n                title: Required[str]\n                year: int\n            m = Movie(\n                title=\'The Matrix\',  # typechecker error if key is omitted\n                year=1999,\n            )\n        There is no runtime checking that a required key is actually provided\n        when instantiating a related TypedDict.\n        """)\n    NotRequired = _RequiredForm(\n        \'NotRequired\',\n        doc="""A special typing construct to mark a key of a TypedDict as\n        potentially missing. For example:\n            class Movie(TypedDict):\n                title: str\n                year: NotRequired[int]\n            m = Movie(\n                title=\'The Matrix\',  # typechecker error if key is omitted\n                year=1999,\n            )\n        """)\nif hasattr(typing, "Unpack"):  \n    Unpack = typing.Unpack\nelif sys.version_info[:2] >= (3, 9):\n    class _UnpackSpecialForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n    class _UnpackAlias(typing._GenericAlias, _root=True):\n        __class__ = typing.TypeVar\n    @_UnpackSpecialForm\n    def Unpack(self, parameters):\n        item = typing._type_check(parameters, f\'{self._name} accepts only a single type.\')\n        return _UnpackAlias(self, (item,))\n    def _is_unpack(obj):\n        return isinstance(obj, _UnpackAlias)\nelse:\n    class _UnpackAlias(typing._GenericAlias, _root=True):\n        __class__ = typing.TypeVar\n    class _UnpackForm(typing._SpecialForm, _root=True):\n        def __repr__(self):\n            return \'typing_extensions.\' + self._name\n        def __getitem__(self, parameters):\n            item = typing._type_check(parameters,\n                                      f\'{self._name} accepts only a single type.\')\n            return _UnpackAlias(self, (item,))\n    Unpack = _UnpackForm(\n        \'Unpack\',\n        doc="""A special typing construct to unpack a variadic type. For example:\n            Shape = TypeVarTuple(\'Shape\')\n            Batch = NewType(\'Batch\', int)\n            def add_batch_axis(\n                x: Array[Unpack[Shape]]\n            ) -> Array[Batch, Unpack[Shape]]: ...\n        """)\n    def _is_unpack(obj):\n        return isinstance(obj, _UnpackAlias)\nif hasattr(typing, "TypeVarTuple"):  \n    TypeVarTuple = typing.TypeVarTuple\nelse:\n    class TypeVarTuple:\n        __class__ = typing.TypeVar\n        def __iter__(self):\n            yield self.__unpacked__\n        def __init__(self, name):\n            self.__name__ = name\n            try:\n                def_mod = sys._getframe(1).f_globals.get(\'__name__\', \'__main__\')\n            except (AttributeError, ValueError):\n                def_mod = None\n            if def_mod != \'typing_extensions\':\n                self.__module__ = def_mod\n            self.__unpacked__ = Unpack[self]\n        def __repr__(self):\n            return self.__name__\n        def __hash__(self):\n            return object.__hash__(self)\n        def __eq__(self, other):\n            return self is other\n        def __reduce__(self):\n            return self.__name__\n        def __init_subclass__(self, *args, **kwds):\n            if \'_root\' not in kwds:\n                raise TypeError("Cannot subclass special typing classes")\nif hasattr(typing, "reveal_type"):\n    reveal_type = typing.reveal_type\nelse:\n    def reveal_type(__obj: T) -> T:\n        print(f"Runtime type is {type(__obj).__name__!r}", file=sys.stderr)\n        return __obj\nif hasattr(typing, "assert_never"):\n    assert_never = typing.assert_never\nelse:\n    def assert_never(__arg: Never) -> Never:\n        raise AssertionError("Expected code to be unreachable")\nif hasattr(typing, \'dataclass_transform\'):\n    dataclass_transform = typing.dataclass_transform\nelse:\n    def dataclass_transform(\n        *,\n        eq_default: bool = True,\n        order_default: bool = False,\n        kw_only_default: bool = False,\n        field_specifiers: typing.Tuple[\n            typing.Union[typing.Type[typing.Any], typing.Callable[..., typing.Any]],\n            ...\n        ] = (),\n        **kwargs: typing.Any,\n    ) -> typing.Callable[[T], T]:\n        def decorator(cls_or_fn):\n            cls_or_fn.__dataclass_transform__ = {\n                "eq_default": eq_default,\n                "order_default": order_default,\n                "kw_only_default": kw_only_default,\n                "field_specifiers": field_specifiers,\n                "kwargs": kwargs,\n            }\n            return cls_or_fn\n        return decorator\nif not hasattr(typing, "TypeVarTuple"):\n    typing._collect_type_vars = _collect_type_vars\n    typing._check_generic = _check_generic\nif sys.version_info >= (3, 11):\n    NamedTuple = typing.NamedTuple\nelse:\n    def _caller():\n        try:\n            return sys._getframe(2).f_globals.get(\'__name__\', \'__main__\')\n        except (AttributeError, ValueError):  \n            return None\n    def _make_nmtuple(name, types, module, defaults=()):\n        fields = [n for n, t in types]\n        annotations = {n: typing._type_check(t, f"field {n} annotation must be a type")\n                       for n, t in types}\n        nm_tpl = collections.namedtuple(name, fields,\n                                        defaults=defaults, module=module)\n        nm_tpl.__annotations__ = nm_tpl.__new__.__annotations__ = annotations\n        if sys.version_info < (3, 9):\n            nm_tpl._field_types = annotations\n        return nm_tpl\n    _prohibited_namedtuple_fields = typing._prohibited\n    _special_namedtuple_fields = frozenset({\'__module__\', \'__name__\', \'__annotations__\'})\n    class _NamedTupleMeta(type):\n        def __new__(cls, typename, bases, ns):\n            assert _NamedTuple in bases\n            for base in bases:\n                if base is not _NamedTuple and base is not typing.Generic:\n                    raise TypeError(\n                        \'can only inherit from a NamedTuple type and Generic\')\n            bases = tuple(tuple if base is _NamedTuple else base for base in bases)\n            types = ns.get(\'__annotations__\', {})\n            default_names = []\n            for field_name in types:\n                if field_name in ns:\n                    default_names.append(field_name)\n                elif default_names:\n                    raise TypeError(f"Non-default namedtuple field {field_name} "\n                                    f"cannot follow default field"\n                                    f"{\'s\' if len(default_names) > 1 else \'\'} "\n                                    f"{\', \'.join(default_names)}")\n            nm_tpl = _make_nmtuple(\n                typename, types.items(),\n                defaults=[ns[n] for n in default_names],\n                module=ns[\'__module__\']\n            )\n            nm_tpl.__bases__ = bases\n            if typing.Generic in bases:\n                class_getitem = typing.Generic.__class_getitem__.__func__\n                nm_tpl.__class_getitem__ = classmethod(class_getitem)\n            for key in ns:\n                if key in _prohibited_namedtuple_fields:\n                    raise AttributeError("Cannot overwrite NamedTuple attribute " + key)\n                elif key not in _special_namedtuple_fields and key not in nm_tpl._fields:\n                    setattr(nm_tpl, key, ns[key])\n            if typing.Generic in bases:\n                nm_tpl.__init_subclass__()\n            return nm_tpl\n    def NamedTuple(__typename, __fields=None, **kwargs):\n        if __fields is None:\n            __fields = kwargs.items()\n        elif kwargs:\n            raise TypeError("Either list of fields or keywords"\n                            " can be provided to NamedTuple, not both")\n        return _make_nmtuple(__typename, __fields, module=_caller())\n    NamedTuple.__doc__ = typing.NamedTuple.__doc__\n    _NamedTuple = type.__new__(_NamedTupleMeta, \'NamedTuple\', (), {})\n    if sys.version_info >= (3, 8):\n        NamedTuple.__text_signature__ = \'(typename, fields=None, /, **kwargs)\'\n    def _namedtuple_mro_entries(bases):\n        assert NamedTuple in bases\n        return (_NamedTuple,)\n    NamedTuple.__mro_entries__ = _namedtuple_mro_entries\n')
    __scriptmerge_write_module('ooodev/events/lo_named_event.py', b'from __future__ import annotations\nfrom typing import NamedTuple\nclass LoNamedEvent(NamedTuple):\n    DISPATCHING = "lo_dispatching"\n    DISPATCHED = "lo_dispatched"\n    DOC_CLOSING = "lo_doc_closing"\n    DOC_CLOSED = "lo_doc_closed"\n    DOC_CREATING = "lo_doc_creating"\n    DOC_CREATED = "lo_doc_created"\n    DOC_OPENING = "lo_doc_opening"\n    DOC_OPENED = "lo_doc_opened"\n    DOC_SAVING = "lo_doc_saving"\n    DOC_SAVED = "lo_doc_saved"\n    DOC_STORING = "lo_doc_storing"\n    DOC_STORED = "lo_doc_stored"\n    OFFICE_LOADING = "lo_office_loading"\n    OFFICE_LOADED = "lo_office_loaded"\n    OFFICE_CLOSING = "lo_office_closing"\n    OFFICE_CLOSED = "lo_office_closed"\n    CONTROLERS_LOCKING = "lo_controllers_locking"\n    CONTROLERS_LOCKED = "lo_controllers_locked"\n    CONTROLERS_UNLOCKING = "lo_controllers_unlocking"\n    CONTROLERS_UNLOCKED = "lo_controllers_unlocked"\n    BRIDGE_DISPOSED = "lo_bridge_disposed"\n    RESET = "lo_reset"\n')
    __scriptmerge_write_module('ooodev/events/gbl_named_event.py', b'from __future__ import annotations\nfrom typing import NamedTuple\nclass GblNamedEvent(NamedTuple):\n    PRINTING = "global_printing"\n')
    __scriptmerge_write_module('ooodev/events/args/cancel_event_args.py', b'from __future__ import annotations\nfrom typing import Any\nfrom .event_args import AbstractEvent\nclass AbstractCancelEventArgs(AbstractEvent):\n    __slots__ = ()\n    def __init__(self, source: Any, cancel=False) -> None:\n        super().__init__(source)\n        self.cancel = cancel\n    cancel: bool\nclass CancelEventArgs(AbstractCancelEventArgs):\n    __slots__ = ("source", "_event_name", "event_data", "cancel", "_event_source")\n    @staticmethod\n    def from_args(args: CancelEventArgs) -> CancelEventArgs:\n        eargs = CancelEventArgs(source=args.source)\n        eargs._event_name = args.event_name\n        eargs._event_source = args.event_source\n        eargs.event_data = args.event_data\n        eargs.cancel = args.cancel\n        return eargs\n')
    __scriptmerge_write_module('ooodev/events/args/dispatch_args.py', b'from __future__ import annotations\nfrom typing import Any\nfrom .event_args import AbstractEvent\nclass AbstractDispacthArgs(AbstractEvent):\n    __slots__ = ()\n    def __init__(self, source: Any, cmd: str) -> None:\n        super().__init__(source)\n        self.cmd = cmd\n    cmd: str\nclass DispatchArgs(AbstractDispacthArgs):\n    __slots__ = ("source", "_event_name", "event_data", "cmd", "_event_source")\n    @staticmethod\n    def from_args(args: DispatchArgs) -> DispatchArgs:\n        eargs = DispatchArgs(source=args.source, cmd=args.cmd)\n        eargs._event_name = args.event_name\n        eargs._event_source = args.event_source\n        eargs.event_data = args.event_data\n        return eargs\n')
    __scriptmerge_write_module('ooodev/events/args/dispatch_cancel_args.py', b'from __future__ import annotations\nfrom typing import Any\nfrom .dispatch_args import AbstractDispacthArgs\nfrom .cancel_event_args import AbstractCancelEventArgs\nclass AbstractDispatchCancelArgs(AbstractDispacthArgs, AbstractCancelEventArgs):\n    __slots__ = ()\n    def __init__(self, source: Any, cmd: str, cancel=False) -> None:\n        super().__init__(source=source, cmd=cmd)\n        self.cancel = cancel\nclass DispatchCancelArgs(AbstractDispatchCancelArgs):\n    __slots__ = ("cmd", "source", "_event_name", "event_data", "cancel", "_event_source")\n    @staticmethod\n    def from_args(args: DispatchCancelArgs) -> DispatchCancelArgs:\n        eargs = DispatchCancelArgs(source=args.source, cmd=args.cmd)\n        eargs._event_name = args.event_name\n        eargs._event_source = args.event_source\n        eargs.event_data = args.event_data\n        eargs.cancel = args.cancel\n        return eargs\n')
    __scriptmerge_write_module('ooodev/meta/__init__.py', b'')
    __scriptmerge_write_module('ooodev/meta/static_meta.py', b'from typing import Any, Callable, TypeVar, Generic\nT = TypeVar("T")\nclass classproperty(Generic[T]):\n    def __init__(self, fget: Callable[[Any], T], fset=None) -> None:\n        self.fget = fget\n        self.fset = fset\n    def __get__(self, obj, objtype=None) -> T:\n        val = self.fget(obj)\n        return val\n    def __set__(self, obj, value: T) -> T:\n        if not self.fset:\n            raise AttributeError("can\'t set attribute")\n        type_ = type(obj)\n        return self.fset.__get__(obj, type_)(value)\n    def setter(self, func):\n        self.fset = func\n        return self\nclass classinstanceproperty(Generic[T]):\n    def __init__(self, fget: Callable[[Any], T], fset=None) -> None:\n        self.fget = fget\n        self.fset = fset\n    def __get__(self, obj, objtype=None) -> T:\n        return self.fget(obj)\n    def __set__(self, obj, value: T) -> T:\n        if not self.fset:\n            raise AttributeError("can\'t set attribute")\n        type_ = type(obj)\n        return self.fset.__get__(obj, type_)(value)\n    def setter(self, func):\n        self.fset = func\n        return self\nclass StaticProperty(type):\n    def __new__(self, name, bases, props):\n        class_properties = {}\n        to_remove = {}\n        for key, value in props.items():\n            if isinstance(value, (classproperty, classinstanceproperty)):\n                class_properties[key] = value\n                if isinstance(value, classproperty):\n                    to_remove[key] = value\n        for key in to_remove:\n            props.pop(key)\n        HoistMeta = type("HoistMeta", (type,), class_properties)\n        return HoistMeta(name, bases, props)\n')
    __scriptmerge_write_module('ooodev/conn/__init__.py', b'')
    __scriptmerge_write_module('ooodev/conn/connect.py', b'from __future__ import annotations\nimport os\nimport time\nfrom abc import ABC, abstractmethod\nimport subprocess\nimport signal\nfrom typing import List, TYPE_CHECKING, cast\nimport time\nimport shutil\nimport uno\nfrom com.sun.star.connection import NoConnectException\nfrom . import connectors\nfrom . import cache\nfrom ..utils.sys_info import SysInfo\nif TYPE_CHECKING:\n    from com.sun.star.beans import XPropertySet\n    from com.sun.star.bridge import XBridgeFactory\n    from com.sun.star.bridge import XBridge\n    from com.sun.star.connection import XConnector\n    from com.sun.star.lang import XComponent\n    from com.sun.star.lang import XMultiComponentFactory\n    from com.sun.star.uno import XComponentContext\nclass ConnectBase(ABC):\n    def __init__(self):\n        self._ctx: XComponentContext = None\n    @abstractmethod\n    def connect(self):\n        ...\n    def kill_soffice(self) -> None:\n        raise NotImplementedError("kill_soffice is not implemented in this child class")\n    @property\n    def ctx(self) -> XComponentContext:\n        return self._ctx\nclass LoBridgeCommon(ConnectBase):\n    def __init__(self, cache_obj: cache.Cache | None):\n        super().__init__()\n        self._soffice_process = None\n        self._bridge_component = None\n        self._platform = SysInfo.get_platform()\n        self._environment = os.environ\n        self._timeout = 30.0\n        self._conn_try_sleep = 0.2\n        if cache_obj is None:\n            self._cache = cache.Cache(use_cache=False)\n        else:\n            self._cache = cache_obj\n        if self._cache.use_cache:\n            self._environment["TMPDIR"] = str(self._cache.working_dir)\n    @abstractmethod\n    def _get_connection_str(self) -> str:\n        ...\n    @abstractmethod\n    def _get_bridge(self, local_factory: XMultiComponentFactory, local_ctx: XComponentContext) -> XBridge:\n        ...\n    def _connect(self):\n        conn_str = self._get_connection_str()\n        end_time = time.time() + self._timeout\n        last_ex = None\n        while end_time > time.time():\n            try:\n                localContext = cast("XComponentContext", uno.getComponentContext())\n                localFactory = localContext.getServiceManager()\n                bridge = self._get_bridge(local_factory=localFactory, local_ctx=localContext)\n                self._bridge_component = bridge.queryInterface(uno.getTypeByName("com.sun.star.lang.XComponent"))\n                smgr = cast(\n                    "XMultiComponentFactory",\n                    bridge.getInstance("StarOffice.ServiceManager").queryInterface(\n                        uno.getTypeByName("com.sun.star.lang.XMultiComponentFactory")\n                    ),\n                )\n                props = cast("XPropertySet", smgr.queryInterface(uno.getTypeByName("com.sun.star.beans.XPropertySet")))\n                self._ctx = props.getPropertyValue("DefaultContext")\n                last_ex = None\n                break\n            except NoConnectException as e:\n                last_ex = e\n                time.sleep(self._conn_try_sleep)\n        if last_ex is not None:\n            raise last_ex\n    def _popen_from_args(self, args: List[str], shutdown: bool):\n        if shutdown == True:\n            if self._platform == SysInfo.PlatformEnum.WINDOWS:\n                cmd_str = " ".join(args)\n                self._soffice_process_shutdown = subprocess.Popen(cmd_str, shell=True, env=self._envirnment)\n            else:\n                self._soffice_process_shutdown = subprocess.Popen(\n                    " ".join(args),\n                    env=self._envirnment,\n                    preexec_fn=os.setsid,\n                    shell=True,\n                )\n        else:\n            cmd_str = " ".join(args)\n            if self._platform == SysInfo.PlatformEnum.WINDOWS:\n                self._soffice_process = subprocess.Popen(cmd_str, shell=True, env=self._environment)\n            else:\n                self._soffice_process = subprocess.Popen(\n                    cmd_str,\n                    env=self._environment,\n                    preexec_fn=os.setsid,\n                    shell=True,\n                )\n    def del_working_dir(self):\n        self._cache.del_working_dir()\n    def get_soffice_pid(self) -> int | None:\n        if self._platform == SysInfo.PlatformEnum.WINDOWS:\n            if self._soffice_process:\n                return self._soffice_process.pid\n            return None\n        else:\n            pid = None\n            try:\n                with open(self._pid_file, "r") as f:\n                    pid = f.read()\n                    pid = int(pid)\n            except:\n                pid = None\n            return pid\n    def _check_pid(self, pid: int) -> bool:\n        if pid <= 0:\n            return False\n        try:\n            os.kill(pid, 0)\n        except OSError:\n            return False\n        else:\n            return True\n    def kill_soffice(self) -> None:\n        try:\n            if self._soffice_process:\n                self._soffice_process.kill()\n            if self._platform == SysInfo.PlatformEnum.WINDOWS:\n                try:\n                    os.system("taskkill /im soffice.bin")\n                except PermissionError:\n                    pass\n                return\n            pid = self.get_soffice_pid()\n            if pid is None:\n                return None\n            if self._check_pid(pid=pid):\n                os.kill(pid, signal.SIGKILL)\n        except Exception as e:\n            raise e\n    @property\n    def cache(self) -> cache.Cache:\n        return self._cache\n    @property\n    def bridge_component(self) -> XComponent:\n        return self._bridge_component\n    def __del__(self) -> None:\n        try:\n            self._cache.del_working_dir()\n        except Exception:\n            pass\nclass LoDirectStart(ConnectBase):\n    def __init__(self):\n        super().__init__()\n    def connect(self):\n        self._ctx = uno.getComponentContext()\n    def kill_soffice(self) -> None:\n        raise NotImplementedError("kill_soffice is not implemented in this child class")\nclass LoPipeStart(LoBridgeCommon):\n    def __init__(self, connector: connectors.ConnectPipe | None = None, cache_obj: cache.Cache | None = None) -> None:\n        super().__init__(cache_obj=cache_obj)\n        if connector is None:\n            self._connector = connectors.ConnectPipe()\n        else:\n            if not isinstance(connector, connectors.ConnectPipe):\n                raise TypeError("connector arg must be ConnectPipe class")\n            self._connector = connector\n    def _get_connection_str(self) -> str:\n        return self._connector.get_connnection_str()\n    def connect(self) -> None:\n        self._cache.copy_cache_to_profile()\n        if self._connector.start_office:\n            self._popen()\n        try:\n            self._connect()\n        except NoConnectException as e:\n            if self._connector.start_office:\n                self.kill_soffice()\n            raise e\n        self._cache.cache_profile()\n    def _get_bridge(self, local_factory: XMultiComponentFactory, local_ctx: XComponentContext) -> XBridge:\n        connector = cast(\n            "XConnector",\n            local_factory.createInstanceWithContext("com.sun.star.connection.Connector", local_ctx).queryInterface(\n                uno.getTypeByName("com.sun.star.connection.XConnector")\n            ),\n        )\n        bridgeFactory = cast(\n            "XBridgeFactory",\n            local_factory.createInstanceWithContext("com.sun.star.bridge.BridgeFactory", local_ctx).queryInterface(\n                uno.getTypeByName("com.sun.star.bridge.XBridgeFactory")\n            ),\n        )\n        xconn = connector.connect(f"pipe,name={self.connector.pipe}")\n        bridge = bridgeFactory.createBridge("PipeBridgeAD", "urp", xconn, None)\n        return bridge\n    def _popen(self, shutdown=False) -> None:\n        if shutdown == True:\n            prefix = "--unaccept="\n        else:\n            prefix = "--accept="\n        args = [f\'"{self._connector.soffice}"\']\n        self._connector.update_startup_args(args)\n        if self._cache.use_cache:\n            args.append(f\'-env:UserInstallation="{self._cache.user_profile.as_uri()}"\')\n        args.append(f\'{prefix}"pipe,name={self._connector.pipe};urp;"\')\n        if self._connector.start_as_service is True:\n            args.append("StarOffice.Service")\n        self._popen_from_args(args, shutdown)\n    @property\n    def connector(self) -> connectors.ConnectPipe:\n        return self._connector\nclass LoSocketStart(LoBridgeCommon):\n    def __init__(\n        self, connector: connectors.ConnectSocket | None = None, cache_obj: cache.Cache | None = None\n    ) -> None:\n        super().__init__(cache_obj=cache_obj)\n        if connector is None:\n            self._connector = connectors.ConnectSocket()\n        else:\n            if not isinstance(connector, connectors.ConnectSocket):\n                raise TypeError("connector arg must be ConnectSocket class")\n            self._connector = connector\n    def _get_connection_str(self) -> str:\n        return self._connector.get_connnection_str()\n    def connect(self) -> None:\n        self._cache.copy_cache_to_profile()\n        if self._connector.start_office:\n            self._popen()\n        try:\n            self._connect()\n        except NoConnectException as e:\n            if self._connector.start_office:\n                self.kill_soffice()\n            raise e\n        self._cache.cache_profile()\n    def _get_bridge(self, local_factory: XMultiComponentFactory, local_ctx: XComponentContext) -> XBridge:\n        connector = cast(\n            "XConnector",\n            local_factory.createInstanceWithContext("com.sun.star.connection.Connector", local_ctx).queryInterface(\n                uno.getTypeByName("com.sun.star.connection.XConnector")\n            ),\n        )\n        bridgeFactory = cast(\n            "XBridgeFactory",\n            local_factory.createInstanceWithContext("com.sun.star.bridge.BridgeFactory", local_ctx).queryInterface(\n                uno.getTypeByName("com.sun.star.bridge.XBridgeFactory")\n            ),\n        )\n        xconn = connector.connect(f"socket,host={self.connector.host},port={self.connector.port},tcpNoDelay=1")\n        bridge = bridgeFactory.createBridge("socketBridgeAD", "urp", xconn, None)\n        return bridge\n    def _popen(self, shutdown=False) -> None:\n        if shutdown == True:\n            prefix = "--unaccept="\n        else:\n            prefix = "--accept="\n        args = [f\'"{self._connector.soffice}"\']\n        self._connector.update_startup_args(args)\n        if self._cache.use_cache:\n            args.append(f\'-env:UserInstallation="{self._cache.user_profile.as_uri()}"\')\n        args.append(f\'{prefix}"socket,host={self._connector.host},port={self._connector.port},tcpNoDelay=1;urp;"\')\n        if self._connector.start_as_service is True:\n            args.append("StarOffice.Service")\n        self._popen_from_args(args, shutdown)\n    @property\n    def connector(self) -> connectors.ConnectSocket:\n        return self._connector\nclass LoManager:\n    def __init__(\n        self,\n        connector: connectors.ConnectPipe | connectors.ConnectSocket | None = None,\n        cache_obj: cache.Cache | None = None,\n    ):\n        if connector is None:\n            self._lo = LoPipeStart(cache_obj=cache_obj)\n        elif isinstance(connector, connectors.ConnectPipe):\n            self._lo = LoPipeStart(connector=connector, cache_obj=cache_obj)\n        elif isinstance(connector, connectors.ConnectSocket):\n            self._lo = LoSocketStart(connector=connector, cache_obj=cache_obj)\n        else:\n            raise TypeError("Arg connector is not valid type")\n    def __enter__(self) -> LoBridgeCommon:\n        self._lo.connect()\n        return self._lo\n    def __exit__(self, exc_type, exc_value, exc_traceback):\n        self._lo.kill_soffice()\n')
    __scriptmerge_write_module('ooodev/conn/connectors.py', b'from __future__ import annotations\nfrom typing import List\nfrom pathlib import Path\nimport uuid\nfrom abc import ABC, abstractmethod\nfrom ..utils import paths\nclass ConnectorBase(ABC):\n    @abstractmethod\n    def get_connnection_str(self) -> str:\n        ...\nclass ConnectorBridgeBase(ConnectorBase):\n    def __init__(self, **kwargs) -> None:\n        self._no_restore = bool(kwargs.get("no_restore", True))\n        self._no_first_start_wizard = bool(kwargs.get("no_first_start_wizard", True))\n        self._no_logo = bool(kwargs.get("no_logo", True))\n        self._invisible = bool(kwargs.get("invisible", True))\n        self._headless = bool(kwargs.get("headless", False))\n        self._start_as_service = bool(kwargs.get("start_as_service", False))\n        self._start_office = bool(kwargs.get("start_office", True))\n        if "soffice" in kwargs:\n            self.soffice = kwargs["soffice"]\n    def update_startup_args(self, args: List[str]) -> None:\n        if self.no_restore:\n            args.append("--norestore")\n        if self.invisible:\n            args.append("--invisible")\n        if self.no_restore:\n            args.append("--norestore")\n        if self.no_first_start_wizard:\n            args.append("--nofirststartwizard")\n        if self.no_logo:\n            args.append("--nologo")\n        if self.headless:\n            args.append("--headless")\n    @property\n    def soffice(self) -> Path:\n        try:\n            return self._soffice\n        except AttributeError:\n            self._soffice = paths.get_soffice_path()\n        return self._soffice\n    @property\n    def start_office(self) -> bool:\n        return self._start_office\n    @start_office.setter\n    def start_office(self, value: bool):\n        self._start_office = value\n    @property\n    def no_restore(self) -> bool:\n        return self._no_restore\n    @no_restore.setter\n    def no_restore(self, value: bool):\n        self._no_restore = value\n    @property\n    def no_first_start_wizard(self) -> bool:\n        return self._no_first_start_wizard\n    @no_first_start_wizard.setter\n    def no_first_start_wizard(self, value: bool):\n        self._no_first_start_wizard = value\n    @property\n    def no_logo(self) -> bool:\n        return self._no_logo\n    @no_logo.setter\n    def no_logo(self, value: bool):\n        self._no_logo = value\n    @property\n    def invisible(self) -> bool:\n        return self._invisible\n    @invisible.setter\n    def invisible(self, value: bool):\n        self._invisible = value\n    @property\n    def headless(self) -> bool:\n        return self._headless\n    @headless.setter\n    def headless(self, value: bool):\n        self._headless = value\n    @property\n    def start_as_service(self) -> bool:\n        return self._start_as_service\n    @start_as_service.setter\n    def start_as_service(self, value: bool):\n        self._start_as_service = value\nclass ConnectSocket(ConnectorBridgeBase):\n    def __init__(self, host="localhost", port=2002, **kwargs) -> None:\n        super().__init__(**kwargs)\n        self._host = host\n        self._port = port\n    def get_connnection_str(self) -> str:\n        identifier = f"socket,host={self.host},port={self.port}"\n        conn_str = f"uno:{identifier};urp;StarOffice.ServiceManager"\n        return conn_str\n    @property\n    def host(self) -> str:\n        return self._host\n    @host.setter\n    def host(self, value: str):\n        self._host = value\n    @property\n    def port(self) -> int:\n        return self._port\n    @port.setter\n    def port(self, value: int):\n        self._port = value\nclass ConnectPipe(ConnectorBridgeBase):\n    def __init__(self, pipe: str | None = None, **kwargs) -> None:\n        super().__init__(**kwargs)\n        if pipe is None:\n            self._pipe = uuid.uuid4().hex\n        else:\n            self._pipe = pipe\n    def get_connnection_str(self) -> str:\n        identifier = f"pipe,name={self.pipe}"\n        conn_str = f"uno:{identifier};urp;StarOffice.ServiceManager"\n        return conn_str\n    @property\n    def pipe(self) -> str:\n        return self._pipe\n    @pipe.setter\n    def pipe(self, value: str):\n        self._pipe = value\n')
    __scriptmerge_write_module('ooodev/utils/paths.py', b'from __future__ import annotations\nimport os\nimport sys\nimport shutil\nimport __main__\nfrom pathlib import Path\nfrom typing import overload\nfrom .sys_info import SysInfo\nfrom .type_var import PathOrStr\nPLATFORM = SysInfo.get_platform()\nif PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n    import winreg\n_INSTALL_PATH = None\ndef get_soffice_install_path() -> Path:\n    global _INSTALL_PATH\n    if _INSTALL_PATH is not None:\n        return _INSTALL_PATH\n    if PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n        value = ""\n        for _key in (\n            "SOFTWARE\\\\LibreOffice\\\\UNO\\\\InstallPath",\n            "SOFTWARE\\\\OpenOffice.org\\\\UNO\\\\InstallPath",\n        ):\n            try:\n                value = winreg.QueryValue(winreg.HKEY_LOCAL_MACHINE, _key)\n            except Exception as detail:\n                value = ""\n                _errMess = "%s" % detail\n            else:\n                break  \n        if value != "":\n            _INSTALL_PATH = Path("\\\\".join(value.split("\\\\")[:-1]))  \n            return _INSTALL_PATH\n        soffice = "soffice.exe"\n        p_sf = Path(os.environ["PROGRAMFILES"], "LibreOffice", "program", soffice)\n        if p_sf.exists() is False or p_sf.is_file() is False:\n            p_sf = Path(os.environ["PROGRAMFILES(X86)"], "LibreOffice", "program", soffice)\n        if not p_sf.exists():\n            raise FileNotFoundError(f"LibreOffice \'{p_sf}\' not found.")\n        if not p_sf.is_file():\n            raise IsADirectoryError(f"LibreOffice \'{p_sf}\' is not a file.")\n        _INSTALL_PATH = p_sf.parent.parent\n        return _INSTALL_PATH\n    elif PLATFORM == SysInfo.PlatformEnum.MAC:\n        _INSTALL_PATH = Path("/Applications/LibreOffice.app/Contents/MacOS")\n        return _INSTALL_PATH\n    else:\n        soffice = "soffice"\n        s = shutil.which(soffice)\n        p_sf = None\n        if s is not None:\n            if os.path.islink(s):\n                p_sf = Path(os.path.realpath(s)).parent\n            else:\n                p_sf = Path(s).parent\n        if p_sf is None:\n            s = "/usr/bin/soffice"\n            if os.path.islink(s):\n                p_sf = Path(os.path.realpath(s)).parent\n            else:\n                p_sf = Path(s).parent\n        if not p_sf.exists():\n            raise FileNotFoundError(f"LibreOffice \'{p_sf}\' not found.")\n        if not p_sf.is_file():\n            raise IsADirectoryError(f"LibreOffice \'{p_sf}\' is not a file.")\n        _INSTALL_PATH = p_sf.parent.parent\n        return _INSTALL_PATH\ndef get_soffice_path() -> Path:\n    if PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n        return Path(get_lo_path(), "soffice.exe")\n    return Path(get_lo_path(), "soffice")\ndef get_uno_path() -> Path:\n    if PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n        p_uno = Path(os.environ["PROGRAMFILES"], "LibreOffice", "program")\n        if p_uno.exists() is False or p_uno.is_dir() is False:\n            p_uno = Path(os.environ["PROGRAMFILES(X86)"], "LibreOffice", "program")\n        if not p_uno.exists():\n            raise FileNotFoundError("Uno Source Dir not found.")\n        if not p_uno.is_dir():\n            raise NotADirectoryError("UNO source is not a Directory")\n        return p_uno\n    elif PLATFORM == SysInfo.PlatformEnum.MAC:\n        return Path("/Applications/LibreOffice.app/Contents/MacOS/soffice")\n    else:\n        p_uno = Path("/usr/lib/python3/dist-packages")\n        if not p_uno.exists():\n            raise FileNotFoundError("Uno Source Dir not found.")\n        if not p_uno.is_dir():\n            raise NotADirectoryError("UNO source is not a Directory")\n        return p_uno\ndef get_lo_path() -> Path:\n    if PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n        return Path(get_soffice_install_path(), "program")\n    elif PLATFORM == SysInfo.PlatformEnum.MAC:\n        return Path("/Applications/LibreOffice.app/Contents/MacOS")\n    else:\n        s = shutil.which("soffice")\n        p_sf = None\n        if s is not None:\n            if os.path.islink(s):\n                p_sf = Path(os.path.realpath(s)).parent\n            else:\n                p_sf = Path(s).parent\n        if p_sf is None:\n            p_sf = Path("/usr/bin/soffice")\n            if p_sf.exists() is False or p_sf.is_file() is False:\n                raise FileNotFoundError("LibreOffice Source Dir not found.")\n            p_sf = p_sf.parent\n        if not p_sf.exists():\n            raise FileNotFoundError("LibreOffice Source Dir not found.")\n        if not p_sf.is_dir():\n            raise NotADirectoryError("LibreOffice source is not a Directory")\n        return p_sf\ndef get_lo_python_ex() -> str:\n    if PLATFORM == SysInfo.PlatformEnum.WINDOWS:\n        p = Path(get_lo_path(), "python.exe")\n        if not p.exists():\n            raise FileNotFoundError("LibreOffice python executable not found.")\n        if not p.is_file():\n            raise NotADirectoryError("LibreOffice  python executable is not a file")\n        return str(p)\n    else:\n        return sys.executable\n@overload\ndef mkdirp(dest_dir: str) -> None:\n    ...\n@overload\ndef mkdirp(dest_dir: Path) -> None:\n    ...\ndef mkdirp(dest_dir:PathOrStr) -> None:\n    pth = Path(dest_dir)\n    if not pth.is_absolute():\n        pth = pth.resolve()\n    pth.mkdir(parents=True, exist_ok=True)\n')
    __scriptmerge_write_module('ooodev/utils/sys_info.py', b'import platform\nfrom enum import Enum\nclass SysInfo:\n    class PlatformEnum(str, Enum):\n        UNKNOWN = \'Unknown\'\n        WINDOWS = "Windows"\n        MAC = "Darwin"\n        LINUX ="Linux"\n    @staticmethod\n    def get_platform() -> \'SysInfo.PlatformEnum\':\n        s = platform.system().lower()\n        if s == \'windows\':\n            return SysInfo.PlatformEnum.WINDOWS\n        if s == \'darwin\':\n            return SysInfo.PlatformEnum.MAC\n        if s == \'linux\':\n            return SysInfo.PlatformEnum.LINUX\n        return SysInfo.PlatformEnum.UNKNOWN\n')
    __scriptmerge_write_module('ooodev/conn/cache.py', b'from __future__ import annotations\nimport os\nfrom pathlib import Path\nfrom shutil import copytree\nimport shutil\nimport tempfile\nfrom ..utils.type_var import PathOrStr\nfrom ..utils import sys_info\nfrom ..cfg import config\nclass Cache:\n    def __init__(self, **kwargs) -> None:\n        self._use_cache = bool(kwargs.get("use_cache", True))\n        self._profile_dir_name = "profile"\n        self._profile_cached = False\n        cache_path = kwargs.get("cache_path", None)\n        if cache_path is not None:\n            self.cache_path = cache_path\n        working_dir = kwargs.get("working_dir", None)\n        if working_dir is not None:\n            self.working_dir = working_dir\n    def _get_cache_path(self) -> Path | None:\n        cache_path = None\n        platform = sys_info.SysInfo.get_platform()\n        def get_path(ver: str):\n            result = None\n            if platform == sys_info.SysInfo.PlatformEnum.LINUX:\n                result = Path("~/.config/libreoffice", ver).expanduser()\n            elif platform == sys_info.SysInfo.PlatformEnum.WINDOWS:\n                result = Path(os.getenv("APPDATA"), "LibreOffice", ver)\n            elif platform == sys_info.SysInfo.PlatformEnum.MAC:\n                result = Path("~/Library/Application Support/LibreOffice/", ver).expanduser()\n            if result is not None:\n                if result.exists() is False or result.is_dir() is False:\n                    result = None\n            if result is None:\n                return False, None\n            return True, result\n        for s_ver in config.Config().profile_versions:\n            is_valid, cache_path = get_path(s_ver)\n            if is_valid:\n                break\n        return cache_path\n    def cache_profile(self) -> None:\n        if self.use_cache is False:\n            return\n        if self.cache_path is None:\n            return\n        if self._profile_cached is False:\n            copytree(self.user_profile, self.cache_path)\n        return\n    def copy_cache_to_profile(self) -> None:\n        if self.use_cache is False:\n            return\n        if self.cache_path is None:\n            return\n        if self.cache_path.exists() and self.cache_path.is_dir():\n            copytree(self.cache_path, self.user_profile)\n            self._profile_cached = True\n        else:\n            os.mkdir(self.user_profile)\n            self._profile_cached = False\n    def del_working_dir(self):\n        if self.use_cache:\n            if self.working_dir.exists() and self.working_dir.is_dir():\n                shutil.rmtree(self.working_dir)\n    @property\n    def user_profile(self) -> Path:\n        try:\n            return self._user_profile\n        except AttributeError:\n            self._user_profile = Path(self.working_dir, self._profile_dir_name)\n        return self._user_profile\n    @property\n    def cache_path(self) -> Path | None:\n        try:\n            return self._cache_path\n        except AttributeError:\n            self._cache_path = self._get_cache_path()\n        return self._cache_path\n    @cache_path.setter\n    def cache_path(self, value: PathOrStr | None):\n        self._cache_path = Path(value)\n    @property\n    def working_dir(self) -> Path:\n        try:\n            return self._working_dir\n        except AttributeError:\n            self._working_dir = Path(tempfile.mkdtemp())\n        return self._working_dir\n    @working_dir.setter\n    def working_dir(self, value: PathOrStr):\n        self._working_dir = Path(value)\n    @property\n    def use_cache(self) -> bool:\n        return self._use_cache\n    @use_cache.setter\n    def use_cache(self, value: bool) -> None:\n        self._use_cache = value\n')
    __scriptmerge_write_module('ooodev/cfg/__init__.py', b'')
    __scriptmerge_write_module('ooodev/cfg/config.py', b'from pathlib import Path\nfrom dataclasses import dataclass\nfrom typing import List\nimport json\nclass ConfigMeta(type):\n    _instance = None\n    def __call__(cls, *args, **kwargs):\n        if cls._instance is None:\n            root = Path(__file__).parent\n            config_file = Path(root, "config.json")\n            if config_file.exists():\n                with open(config_file, "r") as file:\n                    data = json.load(file)\n            else:\n                data = {"profile_versions": ["4"]}\n            cls._instance = super().__call__(**data)\n        return cls._instance\n@dataclass(frozen=True)\nclass Config(metaclass=ConfigMeta):\n    profile_versions: List[str]\n')
    __scriptmerge_write_module('ooodev/listeners/__init__.py', b'')
    __scriptmerge_write_module('ooodev/listeners/x_event_adapter.py', b'from __future__ import annotations\nfrom typing import TYPE_CHECKING\nfrom ..mock import mock_g\nif mock_g.DOCS_BUILDING:\n    from ..mock import unohelper\nelse:\n    import unohelper\nfrom com.sun.star.lang import XEventListener\nif TYPE_CHECKING:\n    from com.sun.star.lang import EventObject\nclass XEventAdapter(unohelper.Base, XEventListener):\n    def disposing(self, event: EventObject) -> None:\n        pass\n')
    __scriptmerge_write_module('ooodev/mock/unohelper.py', b'from .mock_g import DOCS_BUILDING\nif DOCS_BUILDING:\n    from sphinx.ext.autodoc.mock import _MockObject\n    class Base(_MockObject):\n        pass\nelse:\n    import unohelper\n    class Base(unohelper.Base):\n        pass\n')
    __scriptmerge_write_module('ooo/__init__.py', b"__version__ = '0.2.4'\n")
    __scriptmerge_write_module('ooo/dyn/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/document/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/document/macro_exec_mode.py', b'from enum import IntEnum\nfrom typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    from ooo.helper.enum_helper import UnoConstMeta, ConstEnumMeta\n    class MacroExecMode(metaclass=UnoConstMeta, type_name="com.sun.star.document.MacroExecMode", name_space="com.sun.star.document"):\n        pass\n    class MacroExecModeEnum(IntEnum, metaclass=ConstEnumMeta, type_name="com.sun.star.document.MacroExecMode", name_space="com.sun.star.document"):\n        pass\nelse:\n    from ...lo.document.macro_exec_mode import MacroExecMode as MacroExecMode\n    class MacroExecModeEnum(IntEnum):\n        NEVER_EXECUTE = MacroExecMode.NEVER_EXECUTE\n        FROM_LIST = MacroExecMode.FROM_LIST\n        ALWAYS_EXECUTE = MacroExecMode.ALWAYS_EXECUTE\n        USE_CONFIG = MacroExecMode.USE_CONFIG\n        ALWAYS_EXECUTE_NO_WARN = MacroExecMode.ALWAYS_EXECUTE_NO_WARN\n        USE_CONFIG_REJECT_CONFIRMATION = MacroExecMode.USE_CONFIG_REJECT_CONFIRMATION\n        USE_CONFIG_APPROVE_CONFIRMATION = MacroExecMode.USE_CONFIG_APPROVE_CONFIRMATION\n        FROM_LIST_NO_WARN = MacroExecMode.FROM_LIST_NO_WARN\n        FROM_LIST_AND_SIGNED_WARN = MacroExecMode.FROM_LIST_AND_SIGNED_WARN\n        FROM_LIST_AND_SIGNED_NO_WARN = MacroExecMode.FROM_LIST_AND_SIGNED_NO_WARN\n__all__ = [\'MacroExecMode\', \'MacroExecModeEnum\']\n')
    __scriptmerge_write_module('ooo/oenv/__init__.py', b'')
    __scriptmerge_write_module('ooo/oenv/env_const.py', b'try:\n    import uno\nexcept ImportError:\n    pass\nimport sys\nimport os\nfrom typing import TYPE_CHECKING\nUNO_ENVIRONMENT = False\nif not TYPE_CHECKING:\n    UNO_ENVIRONMENT = (\n        "uno" in sys.modules and hasattr(sys.modules["uno"], "getComponentContext")\n    ) and callable(sys.modules["uno"].getComponentContext)\nUNO_RUNTIME = (\n    False\n    if (\n        UNO_ENVIRONMENT is False\n        or os.environ.get("ooouno_ignore_runtime", None) == "True"\n    )\n    else True\n)\nUNO_NONE = object()\n__all__ = ["UNO_ENVIRONMENT", "UNO_RUNTIME", "UNO_NONE"]\n')
    __scriptmerge_write_module('ooo/helper/__init__.py', b'')
    __scriptmerge_write_module('ooo/helper/enum_helper.py', b'from __future__ import annotations\nfrom typing import Any\nimport uno\nfrom enum import Enum, EnumMeta, _EnumDict\ndef uno_enum_class_new(cls, value):\n    if isinstance(value, str):\n        if hasattr(cls, value):\n            return getattr(cls, value)\n    _type = type(value)\n    if _type is uno.Enum:\n        return value\n    if _type is cls:\n        return value\n    raise ValueError("%r is not a valid %s" % (value, cls.__name__))\ndef uno_enum_class_ne(self, other):\n    return not self.__eq__(other)\nclass UnoEnumMeta(type):\n    _initialized = False  \n    typeName = None\n    __ooo_type_name__ = "enum"\n    __ooo_full_ns__ = None\n    __ooo_ns__ = None\n    @classmethod\n    def __prepare__(metacls, name, bases, **kwargs):\n        return super().__prepare__(name, bases, **kwargs)\n    def __new__(metacls, name, bases, namespace, **kwargs):\n        return super().__new__(metacls, name, bases, namespace)\n    def __init__(cls, name, bases, namespace, type_name, name_space, **kwargs):\n        super().__init__(name, bases, namespace)\n        cls.typeName = type_name\n        cls.__ooo_full_ns__ = type_name\n        cls.__ooo_ns__ = name_space\n        cls.__ooo_enum_name__: str = cls.__get_enum_name()\n        cls._initialized = True\n    def __call__(cls, value) -> uno.Enum:\n        if isinstance(value, str):\n            if hasattr(cls, value):\n                return getattr(cls, value)\n        _type = type(value)\n        if _type is uno.Enum:\n            return value\n        if _type is cls:\n            return value\n        raise TypeError("%r is not a valid %s" % (value, cls.__name__))\n    def __getattr__(cls, __name: str) -> uno.Enum | Any:\n        if cls._initialized:\n            try:\n                key = __name\n                e = uno.Enum(cls.typeName, __name)\n                super().__setattr__(key, e)\n                return cls.__dict__[key]\n            except Exception:\n                raise AttributeError(\n                    f"Enum {cls.typeName} has no attribute {__name}")\n        else:\n            try:\n                return cls.__dict__[__name]\n            except KeyError:\n                raise AttributeError(__name)\n    def __setattr__(cls, key, value):\n        if cls._initialized:\n            pass\n        else:\n            super().__setattr__(key, value)  \n    def __get_enum_name(cls) -> str:\n        return cls.__ooo_full_ns__.rsplit(sep=".", maxsplit=1)[1]\nclass ConstEnumMeta(EnumMeta):\n    _initialized = False  \n    __ooo_type_name__ = "const"\n    __ooo_full_ns__ = None\n    __ooo_ns__ = None\n    @classmethod\n    def __prepare__(metacls, cls, bases, **kwds):\n        return super().__prepare__(cls, bases)\n    def __new__(metacls, cls, bases, classdict, **kwds):\n        def set_enum_values(name: str, ns: str, dic: _EnumDict) -> None:\n            m_obj = __import__(name=ns, fromlist=[name])\n            const = getattr(m_obj, name)\n            attrs = [a for a in dir(const) if not a.startswith(\'__\')]\n            for attr in attrs:\n                val = getattr(const, attr, None)\n                if val is not None:\n                    dic[attr] = val\n        type_name: str = kwds["type_name"]\n        name_space: str = kwds["name_space"]\n        enum_name = type_name.rsplit(sep=".", maxsplit=1)[1]\n        set_enum_values(enum_name, name_space, classdict)\n        return super().__new__(metacls, cls, bases, classdict)\n    def __init__(cls, name, bases, namespace, **kwds):\n        super().__init__(name, bases, namespace)\n        type_name = kwds["type_name"]\n        name_space = kwds["name_space"]\n        cls.__ooo_full_ns__: str = type_name\n        cls.__ooo_ns__: str = name_space\n        cls.__ooo_name__: str = cls.__get_enum_name()\n        cls.__ooo_enum_name__: str = cls.__ooo_name__ + "Enum"\n        cls._initialized = True\n    def __call__(cls, value, names=None, *, module=None, qualname=None, type=None, start=1):\n        if isinstance(value, str) and value != cls.__ooo_enum_name__:\n            return cls.__get_enum_from_str(value)\n        return super().__call__(value=value, names=names, module=module, qualname=qualname, type=type, start=start)\n    def __get_enum_name(cls) -> str:\n        return cls.__ooo_full_ns__.rsplit(sep=".", maxsplit=1)[1]\n    def __get_enum_from_str(cls, value: str) -> Enum:\n        if not value:\n            return None\n        val = getattr(cls, value, None)\n        return val\n    def __setattr__(cls, key, value):\n        if cls._initialized:\n            pass\n        else:\n            super().__setattr__(key, value)  \nclass UnoConstMeta(type):\n    _initialized = False  \n    __ooo_type_name__ = "const"\n    __ooo_full_ns__ = None\n    __ooo_ns__ = None\n    @classmethod\n    def __prepare__(metacls, name, bases, **kwargs):\n        return super().__prepare__(name, bases, **kwargs)\n    def __new__(metacls, name, bases, namespace, **kwargs):\n        return super().__new__(metacls, name, bases, namespace)\n    def __init__(cls, name, bases, namespace, type_name, name_space, **kwargs):\n        super().__init__(name, bases, namespace)\n        cls.__ooo_full_ns__ = type_name\n        cls.__ooo_ns__ = name_space\n        cls._initialized = True\n    def __getattr__(cls, name: str) -> uno.Enum | Any:\n        if cls._initialized:\n            try:\n                const = uno.getConstantByName(f"{cls.__ooo_full_ns__}.{name}")\n                super().__setattr__(name, const)\n                return cls.__dict__[name]\n            except Exception:\n                raise AttributeError(\n                    f"Enum {cls.__ooo_full_ns__} has no attribute {name}")\n        else:\n            try:\n                return cls.__dict__[name]\n            except KeyError:\n                raise AttributeError(name)\n    def __setattr__(cls, key, value):\n        if cls._initialized:\n            pass\n        else:\n            super().__setattr__(key, value)\n')
    __scriptmerge_write_module('ooo/lo/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/document/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/document/macro_exec_mode.py', b"class MacroExecMode(object):\n    __ooo_ns__: str = 'com.sun.star.document'\n    __ooo_full_ns__: str = 'com.sun.star.document.MacroExecMode'\n    __ooo_type_name__: str = 'const'\n    NEVER_EXECUTE = 0\n    FROM_LIST = 1\n    ALWAYS_EXECUTE = 2\n    USE_CONFIG = 3\n    ALWAYS_EXECUTE_NO_WARN = 4\n    USE_CONFIG_REJECT_CONFIRMATION = 5\n    USE_CONFIG_APPROVE_CONFIRMATION = 6\n    FROM_LIST_NO_WARN = 7\n    FROM_LIST_AND_SIGNED_WARN = 8\n    FROM_LIST_AND_SIGNED_NO_WARN = 9\n__all__ = ['MacroExecMode']\n")
    __scriptmerge_write_module('ooo/dyn/lang/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/lang/disposed_exception.py', b'from typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    import uno\n    def _get_class():\n        orig_init = None\n        ordered_keys = (\'Message\', \'Context\')\n        def init(self, *args, **kwargs):\n            if len(kwargs) == 0 and len(args) == 1 and getattr(args[0], "__class__", None) == self.__class__:\n                orig_init(self, args[0])\n                return\n            kargs = kwargs.copy()\n            for i, arg in enumerate(args):\n                kargs[ordered_keys[i]] = arg\n            orig_init(self, **kargs)\n        type_name = \'com.sun.star.lang.DisposedException\'\n        ex = uno.getClass(type_name)\n        ex.__ooo_ns__ = \'com.sun.star.lang\'\n        ex.__ooo_full_ns__= type_name\n        ex.__ooo_type_name__ = \'exception\'\n        orig_init = ex.__init__\n        ex.__init__ = init\n        return ex\n    DisposedException = _get_class()\nelse:\n    from ...lo.lang.disposed_exception import DisposedException as DisposedException\n__all__ = [\'DisposedException\']\n')
    __scriptmerge_write_module('ooo/lo/lang/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/lang/disposed_exception.py', b'import typing\nfrom ..uno.runtime_exception import RuntimeException as RuntimeException_d7390ced\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nclass DisposedException(RuntimeException_d7390ced):\n    __ooo_ns__: str = \'com.sun.star.lang\'\n    __ooo_full_ns__: str = \'com.sun.star.lang.DisposedException\'\n    __ooo_type_name__: str = \'exception\'\n    __pyunointerface__: str = \'com.sun.star.lang.DisposedException\'\n    __pyunostruct__: str = \'com.sun.star.lang.DisposedException\'\n    typeName: str = \'com.sun.star.lang.DisposedException\'\n    def __init__(self, Message: typing.Optional[str] = \'\', Context: typing.Optional[XInterface_8f010a43] = None) -> None:\n        kargs = {\n            "Message": Message,\n            "Context": Context,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        super()._init(**kwargs)\n__all__ = [\'DisposedException\']\n')
    __scriptmerge_write_module('ooo/lo/uno/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/uno/runtime_exception.py', b'import typing\nfrom .exception import Exception as Exception_85530a09\nfrom .x_interface import XInterface as XInterface_8f010a43\nclass RuntimeException(Exception_85530a09):\n    __ooo_ns__: str = \'com.sun.star.uno\'\n    __ooo_full_ns__: str = \'com.sun.star.uno.RuntimeException\'\n    __ooo_type_name__: str = \'exception\'\n    __pyunointerface__: str = \'com.sun.star.uno.RuntimeException\'\n    __pyunostruct__: str = \'com.sun.star.uno.RuntimeException\'\n    typeName: str = \'com.sun.star.uno.RuntimeException\'\n    def __init__(self, Message: typing.Optional[str] = \'\', Context: typing.Optional[XInterface_8f010a43] = None) -> None:\n        kargs = {\n            "Message": Message,\n            "Context": Context,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        super()._init(**kwargs)\n__all__ = [\'RuntimeException\']\n')
    __scriptmerge_write_module('ooo/lo/uno/exception.py', b'from ooo.oenv.env_const import UNO_NONE\nimport typing\nfrom .x_interface import XInterface as XInterface_8f010a43\nclass Exception(Exception):\n    __ooo_ns__: str = \'com.sun.star.uno\'\n    __ooo_full_ns__: str = \'com.sun.star.uno.Exception\'\n    __ooo_type_name__: str = \'exception\'\n    __pyunointerface__: str = \'com.sun.star.uno.Exception\'\n    __pyunostruct__: str = \'com.sun.star.uno.Exception\'\n    typeName: str = \'com.sun.star.uno.Exception\'\n    def __init__(self, Message: typing.Optional[str] = \'\', Context: typing.Optional[XInterface_8f010a43] = None) -> None:\n        super().__init__()\n        kargs = {\n            "Message": Message,\n            "Context": Context,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        self._message = kwargs["Message"]\n        self._context = kwargs["Context"]\n    @property\n    def Message(self) -> str:\n        return self._message\n    @Message.setter\n    def Message(self, value: str) -> None:\n        self._message = value\n    @property\n    def Context(self) -> XInterface_8f010a43:\n        return self._context\n    @Context.setter\n    def Context(self, value: XInterface_8f010a43) -> None:\n        self._context = value\n__all__ = [\'Exception\']\n')
    __scriptmerge_write_module('ooo/lo/uno/x_interface.py', b"from abc import abstractmethod, ABC\nclass XInterface(ABC):\n    __ooo_ns__: str = 'com.sun.star.uno'\n    __ooo_full_ns__: str = 'com.sun.star.uno.XInterface'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.uno.XInterface'\n    @abstractmethod\n    def acquire(self) -> None:\n        ...\n    @abstractmethod\n    def queryInterface(self, aType: object) -> object:\n        ...\n    @abstractmethod\n    def release(self) -> None:\n        ...\n__all__ = ['XInterface']\n")
    __scriptmerge_write_module('ooo/dyn/util/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/util/close_veto_exception.py', b'from typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    import uno\n    def _get_class():\n        orig_init = None\n        ordered_keys = (\'Message\', \'Context\')\n        def init(self, *args, **kwargs):\n            if len(kwargs) == 0 and len(args) == 1 and getattr(args[0], "__class__", None) == self.__class__:\n                orig_init(self, args[0])\n                return\n            kargs = kwargs.copy()\n            for i, arg in enumerate(args):\n                kargs[ordered_keys[i]] = arg\n            orig_init(self, **kargs)\n        type_name = \'com.sun.star.util.CloseVetoException\'\n        ex = uno.getClass(type_name)\n        ex.__ooo_ns__ = \'com.sun.star.util\'\n        ex.__ooo_full_ns__= type_name\n        ex.__ooo_type_name__ = \'exception\'\n        orig_init = ex.__init__\n        ex.__init__ = init\n        return ex\n    CloseVetoException = _get_class()\nelse:\n    from ...lo.util.close_veto_exception import CloseVetoException as CloseVetoException\n__all__ = [\'CloseVetoException\']\n')
    __scriptmerge_write_module('ooo/lo/util/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/util/close_veto_exception.py', b'import typing\nfrom ..uno.exception import Exception as Exception_85530a09\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nclass CloseVetoException(Exception_85530a09):\n    __ooo_ns__: str = \'com.sun.star.util\'\n    __ooo_full_ns__: str = \'com.sun.star.util.CloseVetoException\'\n    __ooo_type_name__: str = \'exception\'\n    __pyunointerface__: str = \'com.sun.star.util.CloseVetoException\'\n    __pyunostruct__: str = \'com.sun.star.util.CloseVetoException\'\n    typeName: str = \'com.sun.star.util.CloseVetoException\'\n    def __init__(self, Message: typing.Optional[str] = \'\', Context: typing.Optional[XInterface_8f010a43] = None) -> None:\n        kargs = {\n            "Message": Message,\n            "Context": Context,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        super()._init(**kwargs)\n__all__ = [\'CloseVetoException\']\n')
    __scriptmerge_write_module('ooodev/utils/script_context.py', b'from __future__ import annotations\nfrom typing import TYPE_CHECKING\nimport uno\nimport os\n_ON_RTD = os.environ.get(\'READTHEDOCS\', None) == \'True\'\nif _ON_RTD:\n    from ..mock import unohelper\nelse:\n    import unohelper\nfrom com.sun.star.script.provider import XScriptContext\nif TYPE_CHECKING:\n    from com.sun.star.frame import XDesktop\n    from com.sun.star.frame import XModel\n    from com.sun.star.uno import XComponentContext\nclass ScriptContext(unohelper.Base, XScriptContext):\n    def __init__(self, ctx, desktop, doc):\n        self.ctx = ctx\n        self.desktop = desktop\n        self.doc = doc\n    def getComponentContext(self) -> XComponentContext:\n        return self.ctx\n    def getDesktop(self) -> XDesktop:\n        if self.desktop is None:\n            try:\n                self.desktop = self.ctx.getServiceManager().createInstanceWithContext("com.sun.star.frame.Desktop", self.ctx)\n            except Exception:\n                self.desktop = None\n        return self.desktop\n    def getDocument(self) -> XModel:\n        if self.doc is None:\n            try:\n                self.doc =self.getDesktop().getCurrentComponent()\n            except Exception:\n                self.doc = None\n        return self.doc\n    def getInvocationContext(self):\n        raise os.NotImplementedError\n')
    __scriptmerge_write_module('ooodev/utils/props.py', b'from __future__ import annotations\nfrom typing import Iterable, List, Optional, Sequence, Tuple, TYPE_CHECKING, cast, overload\nimport uno\nfrom com.sun.star.beans import PropertyAttribute  \nfrom com.sun.star.beans import XPropertySet\nfrom com.sun.star.container import XNameAccess\nfrom com.sun.star.document import XTypeDetection\nfrom com.sun.star.ui import ItemType  \nfrom com.sun.star.ui import ItemStyle  \nfrom com.sun.star.uno import RuntimeException\nfrom com.sun.star.beans import PropertyVetoException\nfrom com.sun.star.container import XIndexAccess\nif TYPE_CHECKING:\n    from com.sun.star.beans import Property, PropertyValue\n    from com.sun.star.beans import XMultiPropertySet\nfrom . import lo as mLo\nfrom . import info as mInfo\nfrom ..exceptions import ex as mEx\nclass Props:\n    @staticmethod\n    def make_prop_value(name: Optional[str] = None, value: Optional[str] = None) -> PropertyValue:\n        p: PropertyValue = uno.createUnoStruct("com.sun.star.beans.PropertyValue")\n        if name is not None:\n            p.Name = name\n        if value is not None:\n            p.Value = value\n        return p\n    @classmethod\n    def make_bar_item(\n        cls, cmd: str, item_name: str\n    ) -> Tuple[PropertyValue, PropertyValue, PropertyValue, PropertyValue, PropertyValue]:\n        p1 = cls.make_prop_value(name="CommandURL", value=cmd)\n        p2 = cls.make_prop_value(name="Label", value=item_name)\n        p3 = cls.make_prop_value(name="Type", value=ItemType.DEFAULT)\n        p4 = cls.make_prop_value(name="Visible", value=True)\n        p5 = cls.make_prop_value(name="Style")\n        p5.Value = ItemStyle.DRAW_FLAT + ItemStyle.ALIGN_LEFT + ItemStyle.AUTO_SIZE + ItemStyle.ICON + ItemStyle.TEXT\n        return (p1, p2, p3, p4, p5)\n    @classmethod\n    def make_props(cls, **kwargs) -> Tuple[PropertyValue, ...]:\n        lst = []\n        for k, v in kwargs.items():\n            lst.append(cls.make_prop_value(name=k, value=v))\n        return tuple(lst)\n    @staticmethod\n    def any(*elements: object) -> uno.Any:\n        if len(elements) == 0:\n            raise ValueError("No args to create unn.Any object")\n        obj = elements[0]\n        if isinstance(obj, uno.Type):\n            type_name = obj.typeName\n            return uno.Any(obj, [*elements])\n        if isinstance(obj, str):\n            type_name == obj\n        else:\n            type_name = mInfo.Info.get_type_name(obj)\n        if type_name is None:\n            raise ValueError("Unable to get type name to create uno.Any object")\n        return uno.Any(f"[]{type_name}", [*elements])\n    @staticmethod\n    def set_prop(props: Iterable[PropertyValue], name: str, value: object) -> bool:\n        if props is None:\n            TypeError(f"Property array is null; cannot set {name}")\n        for prop in props:\n            if prop.Name == name:\n                prop.Value = value\n                return True\n        print(f"{name} not found")\n        return False\n    @staticmethod\n    def get_prop(props: Iterable[PropertyValue], name: str) -> object | None:\n        if props is None:\n            TypeError(f"Property array is null; cannot get {name}")\n        for prop in props:\n            if prop.Name == name:\n                return prop.Value\n        print(f"{name} not found")\n        return None\n    @overload\n    @staticmethod\n    def set_property(obj: object, name: str, value: object) -> None:\n        ...\n    @overload\n    @staticmethod\n    def set_property(prop_set: XPropertySet, name: str, value: object) -> None:\n        ...\n    @staticmethod\n    def set_property(*args, **kwargs) -> None:\n        ordered_keys = (1, 2, 3)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("obj", "prop_set", "name", "value")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("set_property() got an unexpected keyword argument")\n            keys = ("obj", "prop_set")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            ka[2] = kwargs.get("name", None)\n            ka[3] = kwargs.get("value", None)\n            return ka\n        if count != 3:\n            raise TypeError("set_property() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        if mLo.Lo.is_uno_interfaces(kargs[1], XPropertySet):\n            prop_set = cast(XPropertySet, kargs[1])\n        else:\n            prop_set = mLo.Lo.qi(XPropertySet, kargs[1])\n            if prop_set is None:\n                raise mEx.MissingInterfaceError(XPropertySet)\n        try:\n            prop_set.setPropertyValue(kargs[2], kargs[3])\n        except Exception as e:\n            raise Exception(f"Could not set property \'{kargs[2]}\'") from e\n    @overload\n    @classmethod\n    def set_properties(cls, obj: object, names: Sequence[str], vals: Sequence[object]) -> None:\n        ...\n    @overload\n    @classmethod\n    def set_properties(cls, prop_set: XPropertySet, names: Sequence[str], vals: Sequence[object]) -> None:\n        ...\n    @overload\n    @classmethod\n    def set_properties(cls, obj: object, from_obj: object) -> None:\n        ...\n    @overload\n    @classmethod\n    def set_properties(cls, prop_set: XPropertySet, from_props: XPropertySet) -> None:\n        ...\n    @classmethod\n    def set_properties(cls, *args, **kwargs) -> None:\n        ordered_keys = (1, 2, 3)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("obj", "prop_set", "names", "from_obj", "from_props", "vals")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("set_properties() got an unexpected keyword argument")\n            keys = ("obj", "prop_set")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            keys = ("names", "from_obj", "from_props")\n            for key in keys:\n                if key in kwargs:\n                    ka[2] = kwargs[key]\n                    break\n            if count == 2:\n                return ka\n            ka[3] = kwargs.get("vals", None)\n            return ka\n        if not count in (2, 3):\n            raise TypeError("set_properties() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        if mInfo.Info.is_type_interface(kargs[1], XPropertySet.__pyunointerface__):\n            prop_set = cast(XPropertySet, kargs[1])\n        else:\n            prop_set = mLo.Lo.qi(XPropertySet, kargs[1])\n            if prop_set is None:\n                raise mEx.MissingInterfaceError(XPropertySet)\n        if count == 3:\n            cls._set_properties_by_vals(prop_set=prop_set, names=kargs[2], vals=kargs[3])\n            return\n        elif count == 2:\n            if mInfo.Info.is_type_interface(kargs[2], XPropertySet.__pyunointerface__):\n                from_props = cast(XPropertySet, kargs[2])\n            else:\n                from_props = mLo.Lo.qi(XPropertySet, kargs[1])\n                if from_props is None:\n                    raise mEx.MissingInterfaceError(XPropertySet)\n            cls._set_properties_from_props(prop_set=prop_set, from_props=from_props)\n    @classmethod\n    def _set_properties_by_vals(cls, prop_set: XPropertySet, names: Sequence[str], vals: Sequence[object]) -> None:\n        errs = []\n        for i, name in enumerate(names):\n            try:\n                prop_set.setPropertyValue(name, vals[i])\n            except PropertyVetoException as e:\n                errs.append(mEx.PropertyError(f"Could not set readonly-property {name}: {e}", e))\n            except Exception as e:\n                errs.append(Exception(f"Cound ont set property {name}: {e}", e))\n        if len(errs) > 0:\n            raise mEx.MultiError(errs)\n    @classmethod\n    def _set_properties_from_props(cls, prop_set: XPropertySet, from_props: XPropertySet) -> None:\n        errs = []\n        if prop_set is None:\n            print(f"Property set is null; cannot set properties")\n            return\n        if from_props is None:\n            print("Source property set is null; cannot set properties")\n            return\n        nms = cls.get_prop_names(from_props)\n        for itm in nms:\n            try:\n                prop_set.setPropertyValue(itm, cls.get_property(from_props, itm))\n            except Exception as e:\n                errs.append(Exception(f"Could not set property \'{itm}\': {e}", e))\n        if len(errs) > 0:\n            raise mEx.MultiError(errs)\n    @overload\n    @staticmethod\n    def get_property(obj: object, name: str) -> object:\n        ...\n    @overload\n    @staticmethod\n    def get_property(prop_set: XPropertySet, name: str) -> object:\n        ...\n    @staticmethod\n    def get_property(*args, **kwargs) -> object:\n        ordered_keys = (1, 2)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("obj", "prop_set", "name")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("get_property() got an unexpected keyword argument")\n            keys = ("obj", "prop_set")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            ka[2] = kwargs.get("name", None)\n            return ka\n        if count != 2:\n            raise TypeError("get_property() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        if mInfo.Info.is_type_interface(kargs[1], XPropertySet.__pyunointerface__):\n            prop_set = cast(XPropertySet, kargs[1])\n        else:\n            prop_set = mLo.Lo.qi(XPropertySet, kargs[1])\n            if prop_set is None:\n                raise mEx.MissingInterfaceError(XPropertySet)\n        name = kargs[2]\n        try:\n            try:\n                return prop_set.getPropertyValue(name)\n            except RuntimeException as e:\n                mEx.PropertyError(name, f"Could not get runtime property \'{name}\': {e}")\n        except Exception as e:\n            raise mEx.PropertyNotFoundError(prop_name=name) from e\n    @staticmethod\n    def get_properties(obj: object) -> Tuple[Property, ...]:\n        prop_set = mLo.Lo.qi(XPropertySet, obj)\n        if prop_set is None:\n            raise mEx.MissingInterfaceError(XPropertySet)\n        props = list(prop_set.getPropertySetInfo().getProperties())\n        props.sort(key=lambda prop: prop.Name)\n        return tuple(props)\n    @staticmethod\n    def get_prop_names(obj: object) -> Tuple[str, ...]:\n        prop_set = mLo.Lo.qi(XPropertySet, obj)\n        if prop_set is None:\n            raise mEx.MissingInterfaceError(XPropertySet)\n        props = prop_set.getPropertySetInfo().getProperties()\n        nms = []\n        for prop in props:\n            nms.append(prop.Name)\n        return tuple(nms)\n    @staticmethod\n    def get_value(name: str, props: Iterable[PropertyValue]) -> object:\n        for prop in props:\n            if prop.Name == name:\n                return prop.Value\n        raise mEx.PropertyNotFoundError(\n            name,\n        )\n    @classmethod\n    def show_indexed_props(cls, title: str, obj: object) -> None:\n        print(f"Indexed Properties for \'{title}\':")\n        in_acc = mLo.Lo.qi(XIndexAccess, obj)\n        if in_acc is None:\n            print("Could not convert object to an IndexAccess container")\n            return\n        num_elems = in_acc.getCount()\n        print(f"No. of elements: {num_elems}")\n        if num_elems == 0:\n            return\n        for i in range(num_elems):\n            try:\n                props = mLo.Lo.qi(XPropertySet, in_acc.getByIndex(i))\n                if props is None:\n                    return\n                cls.show_props(f"Elem {i}", props)\n                print("----")\n            except Exception as e:\n                print(f"Could not get elem {i}: {e}")\n    @classmethod\n    def prop_value_to_string(cls, val: object) -> str:\n        def get_pv_str(vals) -> str:\n            lines = []\n            for p in vals:\n                try:\n                    lines.append(f"{p.Name} = {p.Value}")\n                except AttributeError:\n                    continue\n            return "[\\n    " + "\\n    ".join(lines) + "\\n]"\n        def get_property_set_str(prop_set, props) -> str:\n            lines = []\n            for p in props:\n                value = cls.get_property(prop_set, p.Name)\n                lines.append(f"{p.Name} = {value}")\n            return "[\\n    " + "\\n    ".join(lines) + "\\n]"\n        if val is None:\n            return ""\n        if isinstance(val, str):\n            return val\n        try:\n            _ = iter(val)\n        except TypeError:\n            is_iter = False\n        else:\n            is_iter = True\n        if is_iter:\n            try:\n                if isinstance(val[0], str):\n                    return ", ".join(val)\n            except Exception:\n                pass\n            return get_pv_str(val)\n        else:\n            xprops = mLo.Lo.qi(XPropertySet, val)\n            if xprops is not None:\n                lst = list(cls.props_set_to_tuple(xprops))\n                lst.sort(key=lambda prop: prop.Name)\n                return get_property_set_str(xprops, lst)\n            return str(val)\n    @classmethod\n    def show_values(cls, name: str, props: Iterable[PropertyValue]) -> None:\n        for prop in props:\n            if prop.Name == name:\n                print(f"{prop.Name}: {cls.prop_value_to_string(prop.Value)}")\n                return\n        print(f"{name} not found")\n    @classmethod\n    def show_obj_props(cls, prop_kind: str, obj: object) -> None:\n        prop_set = mLo.Lo.qi(XPropertySet, obj)\n        if prop_set is None:\n            print(f"no {prop_kind} properties found")\n            return\n        cls.show_props(prop_kind=prop_kind, props_set=prop_set)\n    @overload\n    @classmethod\n    def show_props(cls, title: str, props: Sequence[PropertyValue]) -> None:\n        ...\n    @overload\n    @classmethod\n    def show_props(cls, prop_kind: str, props_set: XPropertySet) -> None:\n        ...\n    @classmethod\n    def show_props(cls, *args, **kwargs) -> None:\n        ordered_keys = (1, 2)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("title", "props", "prop_kind", "props_set")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("show_props() got an unexpected keyword argument")\n            keys = ("title", "prop_kind")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            keys = ("props", "props_set")\n            for key in keys:\n                if key in kwargs:\n                    ka[2] = kwargs[key]\n                    break\n            return ka\n        if count != 2:\n            raise TypeError("show_props() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        if mInfo.Info.is_type_interface(kargs[2], "com.sun.star.beans.XPropertySet"):\n            return cls._show_props_str_xpropertyset(prop_kind=kargs[1], props_set=kargs[2])\n        else:\n            return cls._show_props_str_props(title=kargs[1], props=kargs[2])\n    @classmethod\n    def _show_props_str_props(cls, title: str, props: Sequence[PropertyValue]) -> None:\n        print(f"Properties for \'{title}\':")\n        if props is None:\n            print("  none found")\n            return\n        lst = list(props)\n        lst.sort(key=lambda prop: prop.Name)\n        for prop in lst:\n            print(f"  {prop.Name}: {cls.prop_value_to_string(prop.Value)}")\n        print()\n    @classmethod\n    def _show_props_str_xpropertyset(cls, prop_kind: str, props_set: XPropertySet) -> None:\n        props = cls.props_set_to_tuple(props_set)\n        if props is None:\n            print(f"No {prop_kind} properties found")\n            return\n        lst = list(props)\n        lst.sort(key=lambda prop: prop.Name)\n        print(f"{prop_kind} Properties")\n        for prop in lst:\n            prop_value = cls.get_property(props_set, prop.Name)\n            print(f"  {prop.Name}: {prop_value}")\n        print()\n    @staticmethod\n    def props_set_to_tuple(xprops: XPropertySet) -> Tuple[Property, ...]:\n        if xprops is None:\n            return ()\n        xprops_info = xprops.getPropertySetInfo()\n        return xprops_info.getProperties()\n    props_set_to_array = props_set_to_tuple\n    @staticmethod\n    def show_property(p: Property) -> str:\n        return f"{p.Name}: {p.Type.typeName}"\n    @staticmethod\n    def has_property(obj: object, name: str) -> bool:\n        prop_set = mLo.Lo.qi(XPropertySet, obj)\n        if prop_set is None:\n            return False\n        return prop_set.getPropertySetInfo().hasPropertyByName(name)\n    @classmethod\n    def show_doc_type_props(cls, type: str) -> None:\n        if type is None:\n            print("type is None")\n            return\n        xtype_detect = mLo.Lo.create_instance_mcf(XTypeDetection, "com.sun.star.document.TypeDetection")\n        if xtype_detect is None:\n            print("No type detector reference")\n            return\n        xname_access = mLo.Lo.qi(XNameAccess, xtype_detect)\n        try:\n            props = xname_access.getByName(type)\n            cls.show_props(type, props)\n        except Exception:\n            print(f"No properties for \'{type}\'")\n    @staticmethod\n    def get_bound_props(props_set: XMultiPropertySet) -> Tuple[str, ...]:\n        props = props_set.getPropertySetInfo().getProperties()\n        names = []\n        for p in props:\n            is_writable = (p.Attributes & PropertyAttribute.READONLY) == 0\n            is_not_null = (p.Attributes & PropertyAttribute.MAYBEVOID) == 0\n            is_bound = (p.Attributes & PropertyAttribute.BOUND) == 0\n            if is_writable and is_not_null and is_bound:\n                names.append(p.Name)\n        names_len = len(names)\n        if names_len == 0:\n            print("No suitable properties were found")\n            return ()\n        print(f"No. of suitable properties: {names_len}")\n        names.sort()\n        return tuple(names)\n')
    __scriptmerge_write_module('ooodev/utils/info.py', b'from __future__ import annotations\nfrom enum import IntFlag\nfrom pathlib import Path\nimport mimetypes\nfrom typing import TYPE_CHECKING, Tuple, List, cast, overload, Optional\nimport uno\nfrom ..events.event_singleton import _Events\nfrom ..events.lo_named_event import LoNamedEvent\nfrom .sys_info import SysInfo\nfrom com.sun.star.awt import XToolkit\nfrom com.sun.star.beans import XHierarchicalPropertySet\nfrom com.sun.star.beans import XPropertySet\nfrom com.sun.star.container import XContentEnumerationAccess\nfrom com.sun.star.container import XNameAccess\nfrom com.sun.star.container import XNameContainer\nfrom com.sun.star.deployment import XPackageInformationProvider\nfrom com.sun.star.document import XDocumentPropertiesSupplier\nfrom com.sun.star.document import XTypeDetection\nfrom com.sun.star.frame import XModule\nfrom com.sun.star.lang import XMultiServiceFactory\nfrom com.sun.star.lang import XServiceInfo\nfrom com.sun.star.lang import XTypeProvider\nfrom com.sun.star.reflection import XIdlReflection\nfrom com.sun.star.style import XStyleFamiliesSupplier\nfrom com.sun.star.util import XChangesBatch\nif TYPE_CHECKING:\n    from com.sun.star.awt import FontDescriptor\n    from com.sun.star.beans import XPropertyContainer\n    from com.sun.star.document import XDocumentProperties\n    from com.sun.star.reflection import XIdlMethod\nfrom ooo.dyn.beans.property_value import PropertyValue\nfrom ooo.dyn.beans.property_concept import PropertyConceptEnum\nfrom ooo.dyn.beans.the_introspection import theIntrospection\nfrom . import lo as mLo\nfrom . import file_io as mFileIO\nfrom . import props as mProps\nfrom . import date_time_util as mDate\nfrom ..meta.static_meta import StaticProperty, classproperty\nfrom ..exceptions import ex as mEx\nfrom ..events.args.event_args import EventArgs\nfrom .type_var import PathOrStr\nclass Info(metaclass=StaticProperty):\n    REG_MOD_FNM = "registrymodifications.xcu"\n    NODE_PRODUCT = "/org.openoffice.Setup/Product"\n    NODE_L10N = "/org.openoffice.Setup/L10N"\n    NODE_OFFICE = "/org.openoffice.Setup/Office"\n    NODE_PATHS = (NODE_PRODUCT, NODE_L10N)\n    class Filter(IntFlag):\n        IMPORT = 0x00000001\n        EXPORT = 0x00000002\n        TEMPLATE = 0x00000004\n        INTERNAL = 0x00000008\n        TEMPLATEPATH = 0x00000010\n        OWN = 0x00000020\n        ALIEN = 0x00000040\n        DEFAULT = 0x00000100\n        SUPPORTSSELECTION = 0x00000400\n        NOTINFILEDIALOG = 0x00001000\n        NOTINCHOOSER = 0x00002000\n        READONLY = 0x00010000\n        PREFERRED = 0x10000000\n        THIRDPARTYFILTER = 0x00080000\n    @staticmethod\n    def get_fonts() -> Tuple[FontDescriptor, ...]:\n        xtoolkit = mLo.Lo.create_instance_mcf(XToolkit, "com.sun.star.awt.Toolkit")\n        device = xtoolkit.createScreenCompatibleDevice(0, 0)\n        if device is None:\n            mLo.Lo.print("Could not access graphical output device")\n            return ()\n        return device.getFontDescriptors()\n    @classmethod\n    def get_font_names(cls) -> List[str]:\n        fds = cls.get_fonts()\n        if fds is None:\n            return []\n        names_set = set()\n        for name in fds:\n            names_set.add(name)\n        names = list(names_set)\n        names.sort()\n        return names\n    @staticmethod\n    def get_font_mono_name() -> str:\n        pf = SysInfo.get_platform()\n        if pf == SysInfo.PlatformEnum.WINDOWS:\n            return "Courier New"\n        else:\n            return "Liberation Mono"  \n    @staticmethod\n    def get_font_general_name() -> str:\n        pf = SysInfo.get_platform()\n        if pf == SysInfo.PlatformEnum.WINDOWS:\n            return "Times New Roman"\n        else:\n            return "Liberation Serif"  \n    @classmethod\n    def get_reg_mods_path(cls) -> str:\n        user_cfg_dir = mFileIO.FileIO.url_to_path(cls.get_paths("UserConfig"))\n        parent_path = user_cfg_dir.parent\n        return str(parent_path / cls.REG_MOD_FNM)\n    @overload\n    @classmethod\n    def get_reg_item_prop(cls, item: str, prop: str) -> str:\n        ...\n    @overload\n    @classmethod\n    def get_reg_item_prop(cls, item: str, prop: str, node: str) -> str:\n        ...\n    @classmethod\n    def get_reg_item_prop(cls, item: str, prop: str, node: Optional[str] = None) -> str:\n        if mLo.Lo.is_macro_mode:\n            raise mEx.NotSupportedMacroModeError("get_reg_item_prop() is not supported from a macro")\n        try:\n            from lxml import etree as XML_ETREE\n        except ImportError as e:\n            raise Exception("get_reg_item_prop() requires lxml python package") from e\n        try:\n            _xml_parser = XML_ETREE.XMLParser(remove_blank_text=True)\n            fnm = cls.get_reg_mods_path()\n            tree: XML_ETREE._ElementTree = XML_ETREE.parse(fnm, parser=_xml_parser)\n            if node is None:\n                xpath = f"//item[@oor:path=\'/org.openoffice.Office.{item}\']/prop[@oor:name=\'{prop}\']"\n            else:\n                xpath = f"\']/prop[@oor:name=\'{item}\']/node[@oor:name=\'{node}\']/prop[@oor:name=\'{prop}\']"\n            value = tree.xpath(xpath)\n            if value is None:\n                raise Exception("Item Property not found")\n            else:\n                value = str(value).strip()\n                if value == "":\n                    raise Exception("Item Property is white space (?)")\n            return value\n        except Exception as e:\n            raise ValueError("unable to get value from registrymodifications.xcu") from e\n    @overload\n    @classmethod\n    def get_config(cls, node_str: str) -> object:\n        ...\n    @overload\n    @classmethod\n    def get_config(cls, node_str: str, node_path: str) -> object:\n        ...\n    @classmethod\n    def get_config(cls, node_str: str, node_path: Optional[str] = None) -> object:\n        try:\n            if node_path is None:\n                return cls._get_config2(node_str=node_str)\n            return cls._get_config1(node_str=node_str, node_path=node_path)\n        except Exception as e:\n            msg = f"Unable to get configuration for \'{node_str}\'"\n            if node_path is not None:\n                msg += f" with path: \'{node_path}\'"\n            raise mEx.ConfigError(msg) from e\n    @classmethod\n    def _get_config1(cls, node_str: str, node_path: str):\n        props = cls.get_config_props(node_path)\n        return mProps.Props.get_property(prop_set=props, name=node_str)\n    @classmethod\n    def _get_config2(cls, node_str: str) -> object:\n        for node_path in cls.NODE_PATHS:\n            try:\n                return cls._get_config1(node_str=node_str, node_path=node_path)\n            except mEx.PropertyNotFoundError:\n                pass\n        raise mEx.ConfigError(f"{node_str} not found in common node paths")\n    @staticmethod\n    def get_config_props(node_path: str) -> XPropertySet:\n        try:\n            con_prov = mLo.Lo.create_instance_mcf(\n                XMultiServiceFactory, "com.sun.star.configuration.ConfigurationProvider", raise_err=True\n            )\n            p = mProps.Props.make_props(nodepath=node_path)\n            ca = con_prov.createInstanceWithArguments("com.sun.star.configuration.ConfigurationAccess", p)\n            ps = mLo.Lo.qi(XPropertySet, ca, True)\n            return ps\n        except Exception as e:\n            raise mEx.PropertyError(node_path, f"Unable to access config properties for\\n\\n  \'{node_path}\'") from e\n    @staticmethod\n    def get_paths(setting: str) -> str:\n        try:\n            prop_set = mLo.Lo.create_instance_mcf(XPropertySet, "com.sun.star.util.PathSettings", raise_err=True)\n            result = prop_set.getPropertyValue(setting)\n            if result is None:\n                raise ValueError(f"getPropertyValue() for {setting} yielded None")\n            return str(result)\n        except Exception as e:\n            raise ValueError(f"Could not find paths for: {setting}") from e\n    @classmethod\n    def get_dirs(cls, setting: str) -> List[str]:\n        try:\n            paths = cls.get_paths(setting)\n        except ValueError:\n            mLo.Lo.print(f"Cound not find paths for \'{setting}\'")\n            return []\n        paths_arr = paths.split(";")\n        if len(paths_arr) == 0:\n            mLo.Lo.print(f"Cound not split paths for \'{setting}\'")\n            return [str(mFileIO.FileIO.uri_to_path(paths))]\n        dirs = []\n        for el in paths_arr:\n            dirs.append(str(mFileIO.FileIO.uri_to_path(el)))\n        return dirs\n    @classmethod\n    def get_office_dir(cls) -> str:\n        try:\n            addin_dir = cls.get_paths("Addin")\n            addin_path = str(mFileIO.FileIO.uri_to_path(addin_dir))\n            try:\n                idx = addin_path.index("program")\n            except ValueError:\n                mLo.Lo.print("Cound not extract office path")\n                return addin_path\n            p = Path(addin_path[:idx])\n            return str(p)\n        except Exception as e:\n            raise ValueError("Unable to get office dir") from e\n    @classmethod\n    def get_gallery_dir(cls) -> str:\n        try:\n            gallery_dirs = cls.get_dirs("Gallery")\n            if gallery_dirs is None:\n                raise ValueError("No result from get_dir for Gallery")\n            return gallery_dirs[0]\n        except Exception as e:\n            raise ValueError("Unable to get gallery dir") from e\n    @classmethod\n    def create_configuration_view(cls, path: str) -> XHierarchicalPropertySet:\n        try:\n            con_prov = mLo.Lo.create_instance_mcf(\n                XMultiServiceFactory, "com.sun.star.configuration.ConfigurationProvider"\n            )\n            if con_prov is None:\n                raise mEx.MissingInterfaceError(XMultiServiceFactory)\n            _props = mProps.Props.make_props(nodepath=path)\n            root = con_prov.createInstanceWithArguments("com.sun.star.configuration.ConfigurationAccess", _props)\n            ps = mLo.Lo.qi(XHierarchicalPropertySet, root)\n            if ps is None:\n                raise mEx.MissingInterfaceError(XHierarchicalPropertySet)\n            return ps\n        except Exception as e:\n            raise mEx.ConfigError(f"Unable to get configuration view for \'{path}\'") from e\n    @staticmethod\n    def set_config_props(node_path: str) -> XPropertySet:\n        try:\n            con_prov = mLo.Lo.create_instance_mcf(\n                XMultiServiceFactory, "com.sun.star.configuration.ConfigurationProvider"\n            )\n            if con_prov is None:\n                raise mEx.MissingInterfaceError(XMultiServiceFactory)\n            _props = mProps.Props.make_props(nodepath=node_path)\n            ca = con_prov.createInstanceWithArguments("com.sun.star.configuration.ConfigurationAccess", _props)\n            ps = mLo.Lo.qi(XPropertySet, ca)\n            if ps is None:\n                raise mEx.MissingInterfaceError(XPropertySet)\n            return ps\n        except Exception as e:\n            raise mEx.ConfigError(f"Unable to set configuration property for \'{node_path}\'") from e\n    @classmethod\n    def set_config(cls, node_path: str, node_str: str, val: object) -> bool:\n        try:\n            props = cls.set_config_props(node_path=node_path)\n            if props is None:\n                return False\n            mProps.Props.set_property(prop_set=props, name=node_str, value=val)\n            secure_change = mLo.Lo.qi(XChangesBatch, props)\n            if secure_change is None:\n                raise mEx.MissingInterfaceError(XChangesBatch)\n            secure_change.commitChanges()\n            return True\n        except Exception as e:\n            pass\n        return False\n    @staticmethod\n    def get_name(fnm: PathOrStr) -> str:\n        if fnm == "":\n            raise ValueError("Empty string")\n        p = Path(fnm)\n        if not p.is_file():\n            raise ValueError(f"Not a file: \'{fnm}\'")\n        if p.suffix == "":\n            mLo.Lo.print(f"No extension found for \'{fnm}\'")\n            return p.stem\n        return p.stem\n    @staticmethod\n    def get_ext(fnm: PathOrStr) -> str | None:\n        if fnm == "":\n            raise ValueError("Empty string")\n        p = Path(fnm)\n        if p.suffix == "":\n            mLo.Lo.print(f"No extension found for \'{fnm}\'")\n            return None\n        return p.suffix[1:]\n    @staticmethod\n    def get_unique_fnm(fnm: PathOrStr) -> str:\n        p = Path(fnm)\n        fname = p.stem\n        ext = p.suffix\n        i = 1\n        while p.exists():\n            name = f"{fname}{i}{ext}"\n            p = p.parent / name\n            i += 1\n        return str(p)\n    @staticmethod\n    def get_doc_type(fnm: PathOrStr) -> str:\n        try:\n            xdetect = mLo.Lo.create_instance_mcf(XTypeDetection, "com.sun.star.document.TypeDetection", raise_err=True)\n            if not mFileIO.FileIO.is_openable(fnm):\n                raise mEx.UnOpenableError(fnm)\n            url_str = str(mFileIO.FileIO.fnm_to_url(fnm))\n            media_desc = (mProps.Props.make_prop_value(name="URL", value=url_str),)\n            result = xdetect.queryTypeByDescriptor(media_desc, True)\n            if result is None:\n                raise mEx.UnKnownError("queryTypeByDescriptor() is an unknown result")\n            if isinstance(result, str):\n                return result\n            return result[0]\n        except Exception as e:\n            raise ValueError(f"unable to get doc type for \'{fnm}\'") from e\n    @classmethod\n    def report_doc_type(cls, doc: object) -> mLo.Lo.DocType:\n        doc_type = mLo.Lo.DocType.UNKNOWN\n        if cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.WRITER):\n            mLo.Lo.print("A Writer document")\n            doc_type = mLo.Lo.DocType.WRITER\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.IMPRESS):\n            mLo.Lo.print("A Impress document")\n            doc_type = mLo.Lo.DocType.IMPRESS\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.DRAW):\n            mLo.Lo.print("A Draw document")\n            doc_type = mLo.Lo.DocType.DRAW\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.CALC):\n            mLo.Lo.print("A Calc document")\n            doc_type = mLo.Lo.DocType.CALC\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.BASE):\n            mLo.Lo.print("A Base document")\n            doc_type = mLo.Lo.DocType.BASE\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.MATH):\n            mLo.Lo.print("A Math document")\n            doc_type = mLo.Lo.DocType.MATH\n        else:\n            mLo.Lo.print("Unknown document")\n        return doc_type\n    @classmethod\n    def doc_type_service(cls, doc: object) -> mLo.Lo.Service:\n        if cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.WRITER):\n            mLo.Lo.print("A Writer document")\n            return mLo.Lo.Service.WRITER\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.IMPRESS):\n            mLo.Lo.print("A Impress document")\n            return mLo.Lo.Service.IMPRESS\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.DRAW):\n            mLo.Lo.print("A Draw document")\n            return mLo.Lo.Service.DRAW\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.CALC):\n            mLo.Lo.print("A Calc document")\n            return mLo.Lo.Service.CALC\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.BASE):\n            mLo.Lo.print("A Base document")\n            return mLo.Lo.Service.BASE\n        elif cls.is_doc_type(obj=doc, doc_type=mLo.Lo.Service.MATH):\n            mLo.Lo.print("A Math document")\n            return mLo.Lo.Service.MATH\n        else:\n            mLo.Lo.print("Unknown document")\n            return mLo.Lo.Service.UNKNOWN\n    @staticmethod\n    def is_doc_type(obj: object, doc_type: mLo.Lo.Service) -> bool:\n        try:\n            si = mLo.Lo.qi(XServiceInfo, obj)\n            if si is None:\n                return False\n            return si.supportsService(str(doc_type))\n        except Exception:\n            return False\n    @staticmethod\n    def get_implementation_name(obj: object) -> str:\n        try:\n            si = mLo.Lo.qi(XServiceInfo, obj, True)\n            return si.getImplementationName()\n        except Exception as e:\n            raise ValueError("Could not get service information") from e\n    @staticmethod\n    def get_identifier(obj: object) -> str:\n        try:\n            xmod = mLo.Lo.qi(XModule, obj, True)\n            return xmod.getIdentifier()\n        except Exception as e:\n            raise ValueError("Could not get service information") from e\n    @staticmethod\n    def get_mime_type(fnm: PathOrStr) -> str:\n        default = "application/octet-stream"\n        mt = mimetypes.guess_type(fnm)\n        if mt is None:\n            mLo.Lo.print("unable to find mimeypte")\n            return default\n        if mt[0] is None:\n            mLo.Lo.print("unable to find mimeypte")\n            return default\n        return str(mt[0])\n    @staticmethod\n    def mime_doc_type(mime_type: str) -> mLo.Lo.DocType:\n        if mime_type is None or mime_type == "":\n            return mLo.Lo.DocType.UNKNOWN\n        if mime_type.find("vnd.oasis.opendocument.text") >= 0:\n            return mLo.Lo.DocType.WRITER\n        if mime_type.find("vnd.oasis.opendocument.base") >= 0:\n            return mLo.Lo.DocType.BASE\n        if mime_type.find("vnd.oasis.opendocument.spreadsheet") >= 0:\n            return mLo.Lo.DocType.CALC\n        if (\n            mime_type.find("vnd.oasis.opendocument.graphics") >= 0\n            or mime_type.find("vnd.oasis.opendocument.image") >= 0\n            or mime_type.find("vnd.oasis.opendocument.chart") >= 0\n        ):\n            return mLo.Lo.DocType.DRAW\n        if mime_type.find("vnd.oasis.opendocument.presentation") >= 0:\n            return mLo.Lo.DocType.IMPRESS\n        if mime_type.find("vnd.oasis.opendocument.formula") >= 0:\n            return mLo.Lo.DocType.MATH\n        return mLo.Lo.DocType.UNKNOWN\n    @staticmethod\n    def is_image_mime(mime_type: str) -> bool:\n        if mime_type is None or mime_type == "":\n            return False\n        if mime_type.startswith("image/"):\n            return True\n        if mime_type.startswith("application/x-openoffice-bitmap"):\n            return True\n        return False\n    @overload\n    @classmethod\n    def get_service_names(cls) -> List[str]:\n        ...\n    @overload\n    @classmethod\n    def get_service_names(cls, service_name: str) -> List[str]:\n        ...\n    @classmethod\n    def get_service_names(cls, service_name: Optional[str] = None) -> List[str]:\n        if service_name is None:\n            return cls._get_service_names1()\n        return cls._get_service_names2(service_name=service_name)\n    @staticmethod\n    def _get_service_names1() -> List[str]:\n        mc_factory = mLo.Lo.get_component_factory()\n        if mc_factory is None:\n            return []\n        service_names = list(mc_factory.getAvailableServiceNames())\n        service_names.sort()\n        return service_names\n    @staticmethod\n    def _get_service_names2(service_name: str) -> List[str]:\n        names: List[str] = []\n        try:\n            enum_access = mLo.Lo.qi(XContentEnumerationAccess, mLo.Lo.get_component_factory(), True)\n            x_enum = enum_access.createContentEnumeration(service_name)\n            while x_enum.hasMoreElements():\n                si = mLo.Lo.qi(XServiceInfo, x_enum.nextElement())\n                names.append(si.getImplementationName())\n        except Exception as e:\n            mLo.Lo.print(f"Could not collect service names for: {service_name}")\n            raise e\n        if len(names) == 0:\n            mLo.Lo.print(f"No service names found for: {service_name}")\n            return names\n        names.sort()\n        return names\n    @staticmethod\n    def get_services(obj: object) -> List[str]:\n        try:\n            si = mLo.Lo.qi(XServiceInfo, obj, True)\n            names = si.getSupportedServiceNames()\n            service_names = list(names)\n            service_names.sort()\n            return service_names\n        except Exception as e:\n            mLo.Lo.print("Unable to get services")\n            mLo.Lo.print(f"    {e}")\n            raise e\n    @classmethod\n    def show_services(cls, obj_name: str, obj: object) -> None:\n        services = cls.get_services(obj=obj)\n        if services is None:\n            print(f"No supported services found for {obj_name}")\n            return\n        print(f"{obj_name} Supported Services ({len(services)})")\n        for service in services:\n            print(f"\'{service}\'")\n    @staticmethod\n    def support_service(obj: object, service: str) -> bool:\n        if isinstance(service, str):\n            srv = service\n        else:\n            raise TypeError(f"service is expected to be a string")\n        try:\n            si = mLo.Lo.qi(XServiceInfo, obj)\n            if si is None:\n                return False\n            return si.supportsService(srv)\n        except Exception as e:\n            mLo.Lo.print("Errors ocurred in support_service(). Returning False")\n            mLo.Lo.print(f"    {e}")\n            pass\n        return False\n    @staticmethod\n    def get_available_services(obj: object) -> List[str]:\n        services: List[str] = []\n        try:\n            sf = mLo.Lo.qi(XMultiServiceFactory, obj, True)\n            service_names = sf.getAvailableServiceNames()\n            services.extend(service_names)\n            services.sort()\n        except Exception as e:\n            mLo.Lo.print(e)\n            raise Exception() from e\n        return services\n    @staticmethod\n    def get_interface_types(target: object) -> Tuple[object, ...]:\n        try:\n            tp = mLo.Lo.qi(XTypeProvider, target, True)\n            types = tp.getTypes()\n            return types\n        except Exception as e:\n            mLo.Lo.print("Unable to get interface types")\n            mLo.Lo.print(f"    {e}")\n            raise Exception() from e\n    @overload\n    @classmethod\n    def get_interfaces(cls, target: object) -> List[str]:\n        ...\n    @overload\n    @classmethod\n    def get_interfaces(cls, type_provider: XTypeProvider) -> List[str]:\n        ...\n    @classmethod\n    def get_interfaces(cls, *args, **kwargs) -> List[str]:\n        ordered_keys = (1,)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("target", "typeProvider")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("get_interfaces() got an unexpected keyword argument")\n            keys = ("target", "typeProvider")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            return ka\n        if count != 1:\n            raise TypeError("get_interfaces() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        try:\n            if mLo.Lo.is_uno_interfaces(kargs[1], XTypeProvider):\n                type_provider = cast(XTypeProvider, kargs[1])\n            else:\n                type_provider = mLo.Lo.qi(XTypeProvider, kargs[1])\n                if type_provider is None:\n                    raise mEx.MissingInterfaceError(XTypeProvider)\n            types = cast(Tuple[uno.Type, ...], type_provider.getTypes())\n            names_set = set()\n            for t in types:\n                names_set.add(t.typeName)\n            type_names = list(names_set)\n            type_names.sort()\n            return type_names\n        except Exception as e:\n            mLo.Lo.print("Unable to get interfaces")\n            mLo.Lo.print(f"    {e}")\n            raise Exception() from e\n    @classmethod\n    def show_interfaces(cls, obj_name: str, obj: object) -> None:\n        intfs = cls.get_interfaces(obj)\n        if intfs is None:\n            print(f"No interfaces found for {obj_name}")\n            return\n        print(f"{obj_name} Interfaces ({len(intfs)})")\n        for s in intfs:\n            print(f"  {s}")\n    @staticmethod\n    def get_methods_obj(obj: object, property_concept: PropertyConceptEnum | None = None) -> List[str]:\n        if property_concept is None:\n            property_concept = PropertyConceptEnum.ALL\n        try:\n            intro = theIntrospection()\n            result = intro.inspect(obj)\n            methods = result.getMethods(int(property_concept))\n            lst = []\n            for meth in methods:\n                lst.append(meth.getName())\n            lst.sort()\n            return lst\n        except Exception as e:\n            raise Exception(f"Could not get object Methods") from e\n    @staticmethod\n    def get_methods(interface_name: str) -> List[str]:\n        reflection = mLo.Lo.create_instance_mcf(\n            XIdlReflection, "com.sun.star.reflection.CoreReflection", raise_err=True\n        )\n        fname = reflection.forName(interface_name) \n        if fname is None:\n            mLo.Lo.print(f"Could not find the interface name: {interface_name}")\n            return []\n        try:\n            methods: Tuple[XIdlMethod, ...] = fname.getMethods()\n            lst = []\n            for meth in methods:\n                lst.append(meth.getName())\n            lst.sort()\n            return lst\n        except Exception as e:\n            raise Exception(f"Could not get Methods for: {interface_name}") from e\n    @classmethod\n    def show_methods(cls, interfce_name: str) -> None:\n        methods = cls.get_methods(interface_name=interfce_name)\n        if len(methods) == 0:\n            print(f"No methods found for \'{interfce_name}\'")\n            return\n        print(f"{interfce_name} Methods: {len(methods)}")\n        for method in methods:\n            print(f"  {method}")\n    @classmethod\n    def show_methods_obj(cls, obj: object, property_concept: PropertyConceptEnum | None = None) -> None:\n        methods = cls.get_methods_obj(obj=obj, property_concept=property_concept)\n        if len(methods) == 0:\n            print(f"No Object methods found")\n            return\n        print(f"Object Methods: {len(methods)}")\n        for method in methods:\n            print(f"  {method}")\n    @staticmethod\n    def get_style_families(doc: object) -> XNameAccess:\n        try:\n            xsupplier = mLo.Lo.qi(XStyleFamiliesSupplier, doc)\n            if xsupplier is None:\n                raise mEx.MissingInterfaceError(XStyleFamiliesSupplier)\n            return xsupplier.getStyleFamilies()\n        except mEx.MissingInterfaceError:\n            raise\n        except Exception as e:\n            raise Exception("Unable to get family style names") from e\n    @classmethod\n    def get_style_family_names(cls, doc: object) -> List[str]:\n        try:\n            name_acc = cls.get_style_families(doc)\n            names = name_acc.getElementNames()\n            lst = list(names)\n            lst.sort()\n            return lst\n        except Exception as e:\n            raise Exception("Unable to get family style names") from e\n    @classmethod\n    def get_style_container(cls, doc: object, family_style_name: str) -> XNameContainer:\n        name_acc = cls.get_style_families(doc)\n        xcontianer = mLo.Lo.qi(XNameContainer, name_acc.getByName(family_style_name), raise_err=True)\n        return xcontianer\n    @classmethod\n    def get_style_names(cls, doc: object, family_style_name: str) -> List[str]:\n        try:\n            style_container = cls.get_style_container(doc=doc, family_style_name=family_style_name)\n            names = style_container.getElementNames()\n            lst = list(names)\n            lst.sort()\n            return lst\n        except Exception as e:\n            raise Exception("Could not access style names") from e\n    @classmethod\n    def get_style_props(cls, doc: object, family_style_name: str, prop_set_nm: str) -> XPropertySet:\n        style_container = cls.get_style_container(doc, family_style_name)\n        name_props = mLo.Lo.qi(XPropertySet, style_container.getByName(prop_set_nm))\n        if name_props is None:\n            raise mEx.MissingInterfaceError(XPropertySet)\n        return name_props\n    @classmethod\n    def get_page_style_props(cls, doc: object) -> XPropertySet:\n        return cls.get_style_props(doc, "PageStyles", "Standard")\n    @classmethod\n    def get_paragraph_style_props(cls, doc: object) -> XPropertySet:\n        return cls.get_style_props(doc, "ParagraphStyles", "Standard")\n    @classmethod\n    def print_doc_properties(cls, doc: object) -> None:\n        try:\n            doc_props_supp = mLo.Lo.qi(XDocumentPropertiesSupplier, doc, True)\n            dps = doc_props_supp.getDocumentProperties()\n            cls.print_doc_props(dps=dps)\n            ud_props = dps.getUserDefinedProperties()\n            mProps.Props.show_obj_props("UserDefined Info", ud_props)\n        except Exception as e:\n            mLo.Lo.print("Unable to get doc properties")\n            mLo.Lo.print(f"    {e}")\n        return\n    @classmethod\n    def print_doc_props(cls, dps: XDocumentProperties) -> None:\n        print("Document Properties Info")\n        print("  Author: " + dps.Author)\n        print("  Title: " + dps.Title)\n        print("  Subject: " + dps.Subject)\n        print("  Description: " + dps.Description)\n        print("  Generator: " + dps.Generator)\n        keys = dps.Keywords\n        print("  Keywords: ")\n        for keyword in keys:\n            print(f"  {keyword}")\n        print("  Modified by: " + dps.ModifiedBy)\n        print("  Printed by: " + dps.PrintedBy)\n        print("  Template Name: " + dps.TemplateName)\n        print("  Template URL: " + dps.TemplateURL)\n        print("  Autoload URL: " + dps.AutoloadURL)\n        print("  Default Target: " + dps.DefaultTarget)\n        l = dps.Language\n        loc = []\n        loc.append("unknown" if len(l.Language) == 0 else l.Language)\n        loc.append("unknown" if len(l.Country) == 0 else l.Country)\n        loc.append("unknown" if len(l.Variant) == 0 else l.Variant)\n        print(f"  Locale: {\'; \'.join(loc)}")\n        print("  Modification Date: " + mDate.DateUtil.str_date_time(dps.ModificationDate))\n        print("  Creation Date: " + mDate.DateUtil.str_date_time(dps.CreationDate))\n        print("  Print Date: " + mDate.DateUtil.str_date_time(dps.PrintDate))\n        print("  Template Date: " + mDate.DateUtil.str_date_time(dps.TemplateDate))\n        doc_stats = dps.DocumentStatistics\n        print("  Document statistics:")\n        for nv in doc_stats:\n            print(f"  {nv.Name} = {nv.Value}")\n        try:\n            print(f"  Autoload Secs: {dps.AutoloadSecs}")\n        except Exception as e:\n            print(f"  Autoload Secs: {e}")\n        try:\n            print(f"  Editing Cycles: {dps.EditingCycles}")\n        except Exception as e:\n            print(f"  Editing Cycles: {e}")\n        try:\n            print(f"  Editing Duration: {dps.EditingDuration}")\n        except Exception as e:\n            print(f"  Editing Duration: {e}")\n        print()\n    @staticmethod\n    def set_doc_props(doc: object, subject: str, title: str, author: str) -> None:\n        try:\n            dp_supplier = mLo.Lo.qi(XDocumentPropertiesSupplier, doc, True)\n            doc_props = dp_supplier.getDocumentProperties()\n            doc_props.Subject = subject\n            doc_props.Title = title\n            doc_props.Author = author\n        except Exception as e:\n            raise mEx.PropertiesError("Unable to set doc properties") from e\n    @staticmethod\n    def get_user_defined_props(doc: object) -> XPropertyContainer:\n        try:\n            dp_supplier = mLo.Lo.qi(XDocumentPropertiesSupplier, doc)\n            if dp_supplier is None:\n                raise mEx.MissingInterfaceError(XDocumentPropertiesSupplier)\n            dps = dp_supplier.getDocumentProperties()\n            return dps.getUserDefinedProperties()\n        except Exception as e:\n            raise mEx.PropertiesError("Unable to get user defined props") from e\n    @staticmethod\n    def get_pip() -> XPackageInformationProvider:\n        ctx = mLo.Lo.get_context()\n        pip = mLo.Lo.qi(\n            XPackageInformationProvider,\n            ctx.getValueByName("/singletons/com.sun.star.deployment.PackageInformationProvider"),\n            True,\n        )\n        return pip\n    @classmethod\n    def list_extensions(cls) -> None:\n        try:\n            pip = cls.get_pip()\n        except mEx.MissingInterfaceError:\n            print("No package info provider found")\n            return\n        exts_tbl = pip.getExtensionList()\n        print("\\nExtensions:")\n        for i in range(len(exts_tbl)):\n            print(f"{i+1}. ID: {exts_tbl[i][0]}")\n            print(f"   Version: {exts_tbl[i][1]}")\n            print(f"   Loc: {pip.getPackageLocation(exts_tbl[i][0])}")\n            print()\n    @classmethod\n    def get_extension_info(cls, id: str) -> Tuple[str, ...]:\n        try:\n            pip = cls.get_pip()\n        except mEx.MissingInterfaceError:\n            mLo.Lo.print("No package info provider found")\n            return ()\n        exts_tbl = pip.getExtensionList()\n        mLo.Lo.print_table("Extension", exts_tbl)\n        for el in exts_tbl:\n            if el[0] == id:\n                return el\n        mLo.Lo.print(f"Extension {id} is not found")\n        return ()\n    @classmethod\n    def get_extension_loc(cls, id: str) -> str | None:\n        try:\n            pip = cls.get_pip()\n        except mEx.MissingInterfaceError:\n            mLo.Lo.print("No package info provider found")\n            return None\n        return pip.getPackageLocation(id)\n    @staticmethod\n    def get_filter_names() -> Tuple[str, ...]:\n        na = mLo.Lo.create_instance_mcf(XNameAccess, "com.sun.star.document.FilterFactory")\n        if na is None:\n            mLo.Lo.print("No Filter factory found")\n            return ()\n        return na.getElementNames()\n    @staticmethod\n    def get_filter_props(filter_nm: str) -> List[PropertyValue]:\n        na = mLo.Lo.create_instance_mcf(XNameAccess, "com.sun.star.document.FilterFactory")\n        if na is None:\n            mLo.Lo.print("No Filter factory found")\n            return []\n        result = na.getByName(filter_nm)\n        if result is None:\n            mLo.Lo.print(f"No props for filter: {filter_nm}")\n            return []\n        return list(result)\n    @classmethod\n    def is_import(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.IMPORT) == cls.Filter.IMPORT\n    @classmethod\n    def is_export(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.EXPORT) == cls.Filter.EXPORT\n    @classmethod\n    def is_template(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.TEMPLATE) == cls.Filter.TEMPLATE\n    @classmethod\n    def is_internal(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.INTERNAL) == cls.Filter.INTERNAL\n    @classmethod\n    def is_template_path(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.TEMPLATEPATH) == cls.Filter.TEMPLATEPATH\n    @classmethod\n    def is_own(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.OWN) == cls.Filter.OWN\n    @classmethod\n    def is_alien(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.ALIEN) == cls.Filter.ALIEN\n    @classmethod\n    def is_default(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.DEFAULT) == cls.Filter.DEFAULT\n    @classmethod\n    def is_support_selection(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.SUPPORTSSELECTION) == cls.Filter.SUPPORTSSELECTION\n    @classmethod\n    def is_not_in_file_dialog(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.NOTINFILEDIALOG) == cls.Filter.NOTINFILEDIALOG\n    @classmethod\n    def is_not_in_chooser(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.NOTINCHOOSER) == cls.Filter.NOTINCHOOSER\n    @classmethod\n    def is_read_only(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.READONLY) == cls.Filter.READONLY\n    @classmethod\n    def is_third_party_filter(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.THIRDPARTYFILTER) == cls.Filter.THIRDPARTYFILTER\n    @classmethod\n    def is_preferred(cls, filter_flags: Info.Filter) -> bool:\n        return (filter_flags & cls.Filter.PREFERRED) == cls.Filter.PREFERRED\n    @staticmethod\n    def is_type_struct(obj: object, type_name: str) -> bool:\n        if obj is None:\n            return False\n        if hasattr(obj, "typeName"):\n            return obj.typeName == type_name\n        return False\n    @staticmethod\n    def is_type_interface(obj: object, type_name: str) -> bool:\n        return mLo.Lo.is_uno_interfaces(obj, type_name)\n    @staticmethod\n    def is_type_enum(obj: uno.Enum, type_name: str) -> bool:\n        if obj is None:\n            return False\n        if hasattr(obj, "typeName"):\n            return obj.typeName == type_name\n        return False\n    @classmethod\n    def get_type_name(cls, obj: object) -> str | None:\n        if hasattr(obj, "typeName"):\n            return obj.typeName\n        if hasattr(obj, "__ooo_full_ns__"):\n            return obj.__ooo_full_ns__\n        if hasattr(obj, "__pyunointerface__"):\n            return obj.__pyunointerface__\n        return None\n    @classproperty\n    def language(cls) -> str:\n        try:\n            return cls._language\n        except AttributeError:\n            lang = cls.get_config(node_str="ooLocale")\n            cls._language = str(lang)\n        return cls._language\n    @language.setter\n    def language(cls, value) -> None:\n        raise AttributeError("Attempt to modify read-only class property \'%s\'." % cls.__name__)\n    @classproperty\n    def version(cls) -> str:\n        try:\n            return cls._version\n        except AttributeError:\n            lang = cls.get_config(node_str="ooSetupVersion")\n            cls._version = str(lang)\n        return cls._version\n    @version.setter\n    def version(cls, value) -> None:\n        raise AttributeError("Attempt to modify read-only class property \'%s\'." % cls.__name__)\ndef _del_cache_attrs(source: object, e: EventArgs) -> None:\n    dattrs = ("_language", "_version")\n    for attr in dattrs:\n        if hasattr(Info, attr):\n            delattr(Info, attr)\n_Events().on(LoNamedEvent.RESET, _del_cache_attrs)\n__all__ = ("Info",)\n')
    __scriptmerge_write_module('ooo/dyn/beans/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/beans/property_value.py', b'from typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME, UNO_NONE\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    import uno\n    def _get_class():\n        orig_init = None\n        ordered_keys = (\'Name\', \'Handle\', \'Value\', \'State\')\n        def init(self, *args, **kwargs):\n            if len(kwargs) == 0 and len(args) == 1 and getattr(args[0], "__class__", None) == self.__class__:\n                orig_init(self, args[0])\n                return\n            kargs = kwargs.copy()\n            for i, arg in enumerate(args):\n                kargs[ordered_keys[i]] = arg\n            orig_init(self, **kargs)\n        type_name = \'com.sun.star.beans.PropertyValue\'\n        struct = uno.getClass(type_name)\n        struct.__ooo_ns__ = \'com.sun.star.beans\'\n        struct.__ooo_full_ns__= type_name\n        struct.__ooo_type_name__ = \'struct\'\n        orig_init = struct.__init__\n        struct.__init__ = init\n        return struct\n    PropertyValue = _get_class()\nelse:\n    from ...lo.beans.property_value import PropertyValue as PropertyValue\n__all__ = [\'PropertyValue\']\n')
    __scriptmerge_write_module('ooo/lo/beans/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/beans/property_value.py', b'from ooo.oenv.env_const import UNO_NONE\nimport typing\nfrom .property_state import PropertyState as PropertyState_c97b0c77\nclass PropertyValue(object):\n    __ooo_ns__: str = \'com.sun.star.beans\'\n    __ooo_full_ns__: str = \'com.sun.star.beans.PropertyValue\'\n    __ooo_type_name__: str = \'struct\'\n    typeName: str = \'com.sun.star.beans.PropertyValue\'\n    def __init__(self, Name: typing.Optional[str] = \'\', Handle: typing.Optional[int] = 0, Value: typing.Optional[object] = None, State: typing.Optional[PropertyState_c97b0c77] = PropertyState_c97b0c77.DIRECT_VALUE) -> None:\n        super().__init__()\n        if isinstance(Name, PropertyValue):\n            oth: PropertyValue = Name\n            self.Name = oth.Name\n            self.Handle = oth.Handle\n            self.Value = oth.Value\n            self.State = oth.State\n            return\n        kargs = {\n            "Name": Name,\n            "Handle": Handle,\n            "Value": Value,\n            "State": State,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        self._name = kwargs["Name"]\n        self._handle = kwargs["Handle"]\n        self._value = kwargs["Value"]\n        self._state = kwargs["State"]\n    @property\n    def Name(self) -> str:\n        return self._name\n    @Name.setter\n    def Name(self, value: str) -> None:\n        self._name = value\n    @property\n    def Handle(self) -> int:\n        return self._handle\n    @Handle.setter\n    def Handle(self, value: int) -> None:\n        self._handle = value\n    @property\n    def Value(self) -> object:\n        return self._value\n    @Value.setter\n    def Value(self, value: object) -> None:\n        self._value = value\n    @property\n    def State(self) -> PropertyState_c97b0c77:\n        return self._state\n    @State.setter\n    def State(self, value: PropertyState_c97b0c77) -> None:\n        self._state = value\n__all__ = [\'PropertyValue\']\n')
    __scriptmerge_write_module('ooo/lo/beans/property_state.py', b"from enum import Enum\nclass PropertyState(Enum):\n    __ooo_ns__: str = 'com.sun.star.beans'\n    __ooo_full_ns__: str = 'com.sun.star.beans.PropertyState'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.beans.PropertyState'\n    AMBIGUOUS_VALUE = 'AMBIGUOUS_VALUE'\n    DEFAULT_VALUE = 'DEFAULT_VALUE'\n    DIRECT_VALUE = 'DIRECT_VALUE'\n__all__ = ['PropertyState']\n")
    __scriptmerge_write_module('ooo/dyn/beans/property_concept.py', b'from enum import IntEnum\nfrom typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    from ooo.helper.enum_helper import UnoConstMeta, ConstEnumMeta\n    class PropertyConcept(metaclass=UnoConstMeta, type_name="com.sun.star.beans.PropertyConcept", name_space="com.sun.star.beans"):\n        pass\n    class PropertyConceptEnum(IntEnum, metaclass=ConstEnumMeta, type_name="com.sun.star.beans.PropertyConcept", name_space="com.sun.star.beans"):\n        pass\nelse:\n    from ...lo.beans.property_concept import PropertyConcept as PropertyConcept\n    class PropertyConceptEnum(IntEnum):\n        ALL = PropertyConcept.ALL\n        DANGEROUS = PropertyConcept.DANGEROUS\n        PROPERTYSET = PropertyConcept.PROPERTYSET\n        ATTRIBUTES = PropertyConcept.ATTRIBUTES\n        METHODS = PropertyConcept.METHODS\n__all__ = [\'PropertyConcept\', \'PropertyConceptEnum\']\n')
    __scriptmerge_write_module('ooo/lo/beans/property_concept.py', b"class PropertyConcept(object):\n    __ooo_ns__: str = 'com.sun.star.beans'\n    __ooo_full_ns__: str = 'com.sun.star.beans.PropertyConcept'\n    __ooo_type_name__: str = 'const'\n    ALL = -1\n    DANGEROUS = 1\n    PROPERTYSET = 2\n    ATTRIBUTES = 4\n    METHODS = 8\n__all__ = ['PropertyConcept']\n")
    __scriptmerge_write_module('ooo/dyn/beans/the_introspection.py', b"from typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    def _dynamic_singleton() -> None:\n        import uno\n        global theIntrospection\n        def _singleton_init():\n            ctx = uno.getComponentContext()\n            key = '/singletons/com.sun.star.beans.theIntrospection'\n            singleton = ctx.getByName(key)\n            return singleton\n        theIntrospection = _singleton_init\n    _dynamic_singleton()\nelse:\n    from ...lo.beans.the_introspection import theIntrospection as theIntrospection\n__all__ = ['theIntrospection']\n")
    __scriptmerge_write_module('ooo/lo/beans/the_introspection.py', b"from .x_introspection import XIntrospection as XIntrospection_d5510cda\nclass theIntrospection(XIntrospection_d5510cda):\n    __ooo_ns__: str = 'com.sun.star.beans'\n    __ooo_full_ns__: str = 'com.sun.star.beans.theIntrospection'\n    __ooo_type_name__: str = 'singleton'\n    _instance = None\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls, *args, **kwargs)\n        return cls._instance\n__all__ = ['theIntrospection']\n")
    __scriptmerge_write_module('ooo/lo/beans/x_introspection.py', b"import typing\nfrom abc import abstractmethod\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nif typing.TYPE_CHECKING:\n    from .x_introspection_access import XIntrospectionAccess as XIntrospectionAccess_2a050f2c\nclass XIntrospection(XInterface_8f010a43):\n    __ooo_ns__: str = 'com.sun.star.beans'\n    __ooo_full_ns__: str = 'com.sun.star.beans.XIntrospection'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.beans.XIntrospection'\n    @abstractmethod\n    def inspect(self, aObject: object) -> 'XIntrospectionAccess_2a050f2c':\n        ...\n__all__ = ['XIntrospection']\n")
    __scriptmerge_write_module('ooo/lo/beans/x_introspection_access.py', b"import typing\nfrom abc import abstractmethod\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nif typing.TYPE_CHECKING:\n    from .property import Property as Property_8f4e0a76\n    from ..reflection.x_idl_method import XIdlMethod as XIdlMethod_e3740d05\nclass XIntrospectionAccess(XInterface_8f010a43):\n    __ooo_ns__: str = 'com.sun.star.beans'\n    __ooo_full_ns__: str = 'com.sun.star.beans.XIntrospectionAccess'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.beans.XIntrospectionAccess'\n    @abstractmethod\n    def getMethod(self, aName: str, nMethodConcepts: int) -> 'XIdlMethod_e3740d05':\n        ...\n    @abstractmethod\n    def getMethods(self, nMethodConcepts: int) -> 'typing.Tuple[XIdlMethod_e3740d05, ...]':\n        ...\n    @abstractmethod\n    def getProperties(self, nPropertyConcepts: int) -> 'typing.Tuple[Property_8f4e0a76, ...]':\n        ...\n    @abstractmethod\n    def getProperty(self, aName: str, nPropertyConcepts: int) -> 'Property_8f4e0a76':\n        ...\n    @abstractmethod\n    def getSuppliedMethodConcepts(self) -> int:\n        ...\n    @abstractmethod\n    def getSuppliedPropertyConcepts(self) -> int:\n        ...\n    @abstractmethod\n    def getSupportedListeners(self) -> 'typing.Tuple[object, ...]':\n        ...\n    @abstractmethod\n    def hasMethod(self, aName: str, nMethodConcepts: int) -> bool:\n        ...\n    @abstractmethod\n    def hasProperty(self, aName: str, nPropertyConcepts: int) -> bool:\n        ...\n    @abstractmethod\n    def queryAdapter(self, aInterfaceType: object) -> 'XInterface_8f010a43':\n        ...\n__all__ = ['XIntrospectionAccess']\n")
    __scriptmerge_write_module('ooo/lo/beans/property.py', b'from ooo.oenv.env_const import UNO_NONE\nimport typing\nclass Property(object):\n    __ooo_ns__: str = \'com.sun.star.beans\'\n    __ooo_full_ns__: str = \'com.sun.star.beans.Property\'\n    __ooo_type_name__: str = \'struct\'\n    typeName: str = \'com.sun.star.beans.Property\'\n    def __init__(self, Name: typing.Optional[str] = \'\', Handle: typing.Optional[int] = 0, Type: typing.Optional[object] = None, Attributes: typing.Optional[int] = 0) -> None:\n        super().__init__()\n        if isinstance(Name, Property):\n            oth: Property = Name\n            self.Name = oth.Name\n            self.Handle = oth.Handle\n            self.Type = oth.Type\n            self.Attributes = oth.Attributes\n            return\n        kargs = {\n            "Name": Name,\n            "Handle": Handle,\n            "Type": Type,\n            "Attributes": Attributes,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        self._name = kwargs["Name"]\n        self._handle = kwargs["Handle"]\n        self._type = kwargs["Type"]\n        self._attributes = kwargs["Attributes"]\n    @property\n    def Name(self) -> str:\n        return self._name\n    @Name.setter\n    def Name(self, value: str) -> None:\n        self._name = value\n    @property\n    def Handle(self) -> int:\n        return self._handle\n    @Handle.setter\n    def Handle(self, value: int) -> None:\n        self._handle = value\n    @property\n    def Type(self) -> object:\n        return self._type\n    @Type.setter\n    def Type(self, value: object) -> None:\n        self._type = value\n    @property\n    def Attributes(self) -> int:\n        return self._attributes\n    @Attributes.setter\n    def Attributes(self, value: int) -> None:\n        self._attributes = value\n__all__ = [\'Property\']\n')
    __scriptmerge_write_module('ooo/lo/reflection/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/reflection/x_idl_method.py', b"import typing\nfrom abc import abstractmethod\nfrom .x_idl_member import XIdlMember as XIdlMember_e3400cfc\nif typing.TYPE_CHECKING:\n    from .method_mode import MethodMode as MethodMode_e4910d19\n    from .param_info import ParamInfo as ParamInfo_d7210cb0\n    from .x_idl_class import XIdlClass as XIdlClass_d63a0c9a\nclass XIdlMethod(XIdlMember_e3400cfc):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.XIdlMethod'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.reflection.XIdlMethod'\n    @abstractmethod\n    def getExceptionTypes(self) -> 'typing.Tuple[XIdlClass_d63a0c9a, ...]':\n        ...\n    @abstractmethod\n    def getMode(self) -> 'MethodMode_e4910d19':\n        ...\n    @abstractmethod\n    def getParameterInfos(self) -> 'typing.Tuple[ParamInfo_d7210cb0, ...]':\n        ...\n    @abstractmethod\n    def getParameterTypes(self) -> 'typing.Tuple[XIdlClass_d63a0c9a, ...]':\n        ...\n    @abstractmethod\n    def getReturnType(self) -> 'XIdlClass_d63a0c9a':\n        ...\n    @abstractmethod\n    def invoke(self, obj: object, args: object) -> object:\n        ...\n__all__ = ['XIdlMethod']\n")
    __scriptmerge_write_module('ooo/lo/reflection/x_idl_member.py', b"import typing\nfrom abc import abstractmethod\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nif typing.TYPE_CHECKING:\n    from .x_idl_class import XIdlClass as XIdlClass_d63a0c9a\nclass XIdlMember(XInterface_8f010a43):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.XIdlMember'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.reflection.XIdlMember'\n    @abstractmethod\n    def getDeclaringClass(self) -> 'XIdlClass_d63a0c9a':\n        ...\n    @abstractmethod\n    def getName(self) -> str:\n        ...\n__all__ = ['XIdlMember']\n")
    __scriptmerge_write_module('ooo/lo/reflection/x_idl_class.py', b"import typing\nfrom abc import abstractmethod\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nif typing.TYPE_CHECKING:\n    from .x_idl_array import XIdlArray as XIdlArray_d65d0ca3\n    from .x_idl_field import XIdlField as XIdlField_d62c0c88\n    from .x_idl_method import XIdlMethod as XIdlMethod_e3740d05\n    from ..uno.type_class import TypeClass as TypeClass_853109f2\n    from ..uno.uik import Uik as Uik_4fac0783\nclass XIdlClass(XInterface_8f010a43):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.XIdlClass'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.reflection.XIdlClass'\n    @abstractmethod\n    def createObject(self, obj: object) -> None:\n        ...\n    @abstractmethod\n    def equals(self, Type: 'XIdlClass') -> bool:\n        ...\n    @abstractmethod\n    def getArray(self) -> 'XIdlArray_d65d0ca3':\n        ...\n    @abstractmethod\n    def getClass(self, aName: str) -> 'XIdlClass':\n        ...\n    @abstractmethod\n    def getClasses(self) -> 'typing.Tuple[XIdlClass, ...]':\n        ...\n    @abstractmethod\n    def getComponentType(self) -> 'XIdlClass':\n        ...\n    @abstractmethod\n    def getField(self, aName: str) -> 'XIdlField_d62c0c88':\n        ...\n    @abstractmethod\n    def getFields(self) -> 'typing.Tuple[XIdlField_d62c0c88, ...]':\n        ...\n    @abstractmethod\n    def getInterfaces(self) -> 'typing.Tuple[XIdlClass, ...]':\n        ...\n    @abstractmethod\n    def getMethod(self, aName: str) -> 'XIdlMethod_e3740d05':\n        ...\n    @abstractmethod\n    def getMethods(self) -> 'typing.Tuple[XIdlMethod_e3740d05, ...]':\n        ...\n    @abstractmethod\n    def getName(self) -> str:\n        ...\n    @abstractmethod\n    def getSuperclasses(self) -> 'typing.Tuple[XIdlClass, ...]':\n        ...\n    @abstractmethod\n    def getTypeClass(self) -> 'TypeClass_853109f2':\n        ...\n    @abstractmethod\n    def getUik(self) -> 'Uik_4fac0783':\n        ...\n    @abstractmethod\n    def isAssignableFrom(self, xType: 'XIdlClass') -> bool:\n        ...\n__all__ = ['XIdlClass']\n")
    __scriptmerge_write_module('ooo/lo/reflection/x_idl_array.py', b"from abc import abstractmethod\nfrom ..uno.x_interface import XInterface as XInterface_8f010a43\nclass XIdlArray(XInterface_8f010a43):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.XIdlArray'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.reflection.XIdlArray'\n    @abstractmethod\n    def get(self, aArray: object, nIndex: int) -> object:\n        ...\n    @abstractmethod\n    def getLen(self, array: object) -> int:\n        ...\n    @abstractmethod\n    def realloc(self, array: object, length: int) -> None:\n        ...\n    @abstractmethod\n    def set(self, aArray: object, nIndex: int, aNewValue: object) -> None:\n        ...\n__all__ = ['XIdlArray']\n")
    __scriptmerge_write_module('ooo/lo/reflection/x_idl_field.py', b"import typing\nfrom abc import abstractmethod\nfrom .x_idl_member import XIdlMember as XIdlMember_e3400cfc\nif typing.TYPE_CHECKING:\n    from .field_access_mode import FieldAccessMode as FieldAccessMode_2a300eee\n    from .x_idl_class import XIdlClass as XIdlClass_d63a0c9a\nclass XIdlField(XIdlMember_e3400cfc):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.XIdlField'\n    __ooo_type_name__: str = 'interface'\n    __pyunointerface__: str = 'com.sun.star.reflection.XIdlField'\n    @abstractmethod\n    def get(self, obj: object) -> object:\n        ...\n    @abstractmethod\n    def getAccessMode(self) -> 'FieldAccessMode_2a300eee':\n        ...\n    @abstractmethod\n    def getType(self) -> 'XIdlClass_d63a0c9a':\n        ...\n    @abstractmethod\n    def set(self, obj: object, value: object) -> None:\n        ...\n__all__ = ['XIdlField']\n")
    __scriptmerge_write_module('ooo/lo/reflection/field_access_mode.py', b"from enum import Enum\nclass FieldAccessMode(Enum):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.FieldAccessMode'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.reflection.FieldAccessMode'\n    CONST = 'CONST'\n    READONLY = 'READONLY'\n    READWRITE = 'READWRITE'\n    WRITEONLY = 'WRITEONLY'\n__all__ = ['FieldAccessMode']\n")
    __scriptmerge_write_module('ooo/lo/uno/type_class.py', b"from enum import Enum\nclass TypeClass(Enum):\n    __ooo_ns__: str = 'com.sun.star.uno'\n    __ooo_full_ns__: str = 'com.sun.star.uno.TypeClass'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.uno.TypeClass'\n    ANY = 'ANY'\n    ARRAY = 'ARRAY'\n    BOOLEAN = 'BOOLEAN'\n    BYTE = 'BYTE'\n    CHAR = 'CHAR'\n    CONSTANT = 'CONSTANT'\n    CONSTANTS = 'CONSTANTS'\n    DOUBLE = 'DOUBLE'\n    ENUM = 'ENUM'\n    EXCEPTION = 'EXCEPTION'\n    FLOAT = 'FLOAT'\n    HYPER = 'HYPER'\n    INTERFACE = 'INTERFACE'\n    INTERFACE_ATTRIBUTE = 'INTERFACE_ATTRIBUTE'\n    INTERFACE_METHOD = 'INTERFACE_METHOD'\n    LONG = 'LONG'\n    MODULE = 'MODULE'\n    PROPERTY = 'PROPERTY'\n    SEQUENCE = 'SEQUENCE'\n    SERVICE = 'SERVICE'\n    SHORT = 'SHORT'\n    SINGLETON = 'SINGLETON'\n    STRING = 'STRING'\n    STRUCT = 'STRUCT'\n    TYPE = 'TYPE'\n    TYPEDEF = 'TYPEDEF'\n    UNION = 'UNION'\n    UNKNOWN = 'UNKNOWN'\n    UNSIGNED_HYPER = 'UNSIGNED_HYPER'\n    UNSIGNED_LONG = 'UNSIGNED_LONG'\n    UNSIGNED_SHORT = 'UNSIGNED_SHORT'\n    VOID = 'VOID'\n__all__ = ['TypeClass']\n")
    __scriptmerge_write_module('ooo/lo/uno/uik.py', b'from ooo.oenv.env_const import UNO_NONE\nimport typing\nclass Uik(object):\n    __ooo_ns__: str = \'com.sun.star.uno\'\n    __ooo_full_ns__: str = \'com.sun.star.uno.Uik\'\n    __ooo_type_name__: str = \'struct\'\n    typeName: str = \'com.sun.star.uno.Uik\'\n    def __init__(self, Data1: typing.Optional[int] = 0, Data2: typing.Optional[int] = 0, Data3: typing.Optional[int] = 0, Data4: typing.Optional[int] = 0, Data5: typing.Optional[int] = 0) -> None:\n        super().__init__()\n        if isinstance(Data1, Uik):\n            oth: Uik = Data1\n            self.Data1 = oth.Data1\n            self.Data2 = oth.Data2\n            self.Data3 = oth.Data3\n            self.Data4 = oth.Data4\n            self.Data5 = oth.Data5\n            return\n        kargs = {\n            "Data1": Data1,\n            "Data2": Data2,\n            "Data3": Data3,\n            "Data4": Data4,\n            "Data5": Data5,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        self._data1 = kwargs["Data1"]\n        self._data2 = kwargs["Data2"]\n        self._data3 = kwargs["Data3"]\n        self._data4 = kwargs["Data4"]\n        self._data5 = kwargs["Data5"]\n    @property\n    def Data1(self) -> int:\n        return self._data1\n    @Data1.setter\n    def Data1(self, value: int) -> None:\n        self._data1 = value\n    @property\n    def Data2(self) -> int:\n        return self._data2\n    @Data2.setter\n    def Data2(self, value: int) -> None:\n        self._data2 = value\n    @property\n    def Data3(self) -> int:\n        return self._data3\n    @Data3.setter\n    def Data3(self, value: int) -> None:\n        self._data3 = value\n    @property\n    def Data4(self) -> int:\n        return self._data4\n    @Data4.setter\n    def Data4(self, value: int) -> None:\n        self._data4 = value\n    @property\n    def Data5(self) -> int:\n        return self._data5\n    @Data5.setter\n    def Data5(self, value: int) -> None:\n        self._data5 = value\n__all__ = [\'Uik\']\n')
    __scriptmerge_write_module('ooo/lo/reflection/method_mode.py', b"from enum import Enum\nclass MethodMode(Enum):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.MethodMode'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.reflection.MethodMode'\n    ONEWAY = 'ONEWAY'\n    TWOWAY = 'TWOWAY'\n__all__ = ['MethodMode']\n")
    __scriptmerge_write_module('ooo/lo/reflection/param_info.py', b'from ooo.oenv.env_const import UNO_NONE\nimport typing\nfrom .param_mode import ParamMode as ParamMode_d7260ca9\nfrom .x_idl_class import XIdlClass as XIdlClass_d63a0c9a\nclass ParamInfo(object):\n    __ooo_ns__: str = \'com.sun.star.reflection\'\n    __ooo_full_ns__: str = \'com.sun.star.reflection.ParamInfo\'\n    __ooo_type_name__: str = \'struct\'\n    typeName: str = \'com.sun.star.reflection.ParamInfo\'\n    def __init__(self, aName: typing.Optional[str] = \'\', aMode: typing.Optional[ParamMode_d7260ca9] = ParamMode_d7260ca9.IN, aType: typing.Optional[XIdlClass_d63a0c9a] = None) -> None:\n        super().__init__()\n        if isinstance(aName, ParamInfo):\n            oth: ParamInfo = aName\n            self.aName = oth.aName\n            self.aMode = oth.aMode\n            self.aType = oth.aType\n            return\n        kargs = {\n            "aName": aName,\n            "aMode": aMode,\n            "aType": aType,\n        }\n        self._init(**kargs)\n    def _init(self, **kwargs) -> None:\n        self._a_name = kwargs["aName"]\n        self._a_mode = kwargs["aMode"]\n        self._a_type = kwargs["aType"]\n    @property\n    def aName(self) -> str:\n        return self._a_name\n    @aName.setter\n    def aName(self, value: str) -> None:\n        self._a_name = value\n    @property\n    def aMode(self) -> ParamMode_d7260ca9:\n        return self._a_mode\n    @aMode.setter\n    def aMode(self, value: ParamMode_d7260ca9) -> None:\n        self._a_mode = value\n    @property\n    def aType(self) -> XIdlClass_d63a0c9a:\n        return self._a_type\n    @aType.setter\n    def aType(self, value: XIdlClass_d63a0c9a) -> None:\n        self._a_type = value\n__all__ = [\'ParamInfo\']\n')
    __scriptmerge_write_module('ooo/lo/reflection/param_mode.py', b"from enum import Enum\nclass ParamMode(Enum):\n    __ooo_ns__: str = 'com.sun.star.reflection'\n    __ooo_full_ns__: str = 'com.sun.star.reflection.ParamMode'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.reflection.ParamMode'\n    IN = 'IN'\n    INOUT = 'INOUT'\n    OUT = 'OUT'\n__all__ = ['ParamMode']\n")
    __scriptmerge_write_module('ooodev/utils/file_io.py', b'from __future__ import annotations\nimport os\nimport tempfile\nimport datetime\nimport glob\nimport zipfile\nfrom pathlib import Path\nfrom urllib.parse import urlparse\nfrom typing import List, TYPE_CHECKING\nimport uno\nfrom com.sun.star.io import XActiveDataSink\nfrom com.sun.star.io import XTextInputStream\nfrom com.sun.star.packages.zip import XZipFileAccess\nfrom com.sun.star.uno import Exception as UnoException\nif TYPE_CHECKING:\n    from com.sun.star.container import XNameAccess\n    from com.sun.star.io import XInputStream\nfrom . import lo as mLo\nfrom .type_var import PathOrStr\n_UTIL_PATH = str(Path(__file__).parent)\nclass FileIO:\n    @staticmethod\n    def get_utils_folder() -> str:\n        return _UTIL_PATH\n    @staticmethod\n    def get_absolute_path(fnm: PathOrStr) -> Path:\n        p = Path(fnm)\n        if p.is_absolute():\n            return p\n        return p.absolute().resolve()\n    @classmethod\n    def url_to_path(cls, url: str) -> Path:\n        try:\n            p = urlparse(url)\n            final_path = cls.get_absolute_path(os.path.join(p.netloc, p.path))\n            return final_path\n        except Exception as e:\n            raise Exception(f"Could not parse \'{url}\'")\n    @classmethod\n    def fnm_to_url(cls, fnm: PathOrStr) -> str:\n        try:\n            p =  cls.get_absolute_path(fnm)\n            return p.as_uri()\n        except Exception as e:\n            raise Exception("Unable to convert \'{fnm}\'") from e\n    @classmethod\n    def uri_to_path(cls, uri_fnm: str) -> Path:\n        p = Path(uri_fnm)\n        if p.is_absolute():\n            return p\n        return p.absolute().resolve()\n    @staticmethod\n    def get_file_names(dir: PathOrStr) -> List[str]:\n        files = glob.glob(f"{dir}/.*", recursive=False)\n        return files\n    @staticmethod\n    def get_fnm(path: PathOrStr) -> str:\n        if path == "":\n            mLo.Lo.print("path is an empty string")\n            return ""\n        try:\n            p = Path(path)\n            return p.name\n        except Exception as e:\n            mLo.Lo.print(f"Unable to get name for \'{path}\'")\n            mLo.Lo.print(f"    {e}")\n        return ""\n    @classmethod\n    def is_openable(cls, fnm: PathOrStr) -> bool:\n        try:\n            p = cls.get_absolute_path(fnm)\n            if not p.exists():\n                mLo.Lo.print(f"\'{fnm}\' does not exist")\n                return False\n            if not p.is_file():\n                mLo.Lo.print(f"\'{fnm}\' does is not a file")\n                return False\n            if not os.access(fnm, os.R_OK):\n                mLo.Lo.print(f"\'{fnm}\' is not readable")\n                return False\n            return True\n        except Exception as e:\n            mLo.Lo.print(f"File is not openable: {e}")\n        return False\n    @classmethod\n    def make_directory(cls, dir: PathOrStr) -> None:\n        p = cls.get_absolute_path(dir)\n        p.mkdir(parents=True, exist_ok=True)\n    @staticmethod\n    def create_temp_file(im_format: str) -> str:\n        try:\n            tmp = tempfile.NamedTemporaryFile(prefix="loTemp", suffix=f".{im_format}", delete=True)\n            return tmp.name\n        except Exception as e:\n            raise Exception("Could not create temp file") from e\n    @classmethod\n    def delete_file(cls, fnm: PathOrStr) -> bool:\n        p = cls.get_absolute_path(fnm)\n        os.remove(p)\n        if p.exists():\n            mLo.Lo.print(f"\'{p}\' could not be deleted")\n            return False\n        else:\n            mLo.Lo.print(f"\'{p}\' deleted")\n        return True\n    @classmethod\n    def delete_files(cls, *fnms:PathOrStr) -> bool:\n        if len(fnms) == 0:\n            return False\n        mLo.Lo.print()\n        result = True\n        for s in fnms:\n            result = result and cls.delete_file(s)\n        return result\n    @classmethod\n    def save_string(cls, fnm: PathOrStr, data: str) -> None:\n        if data is None:\n            raise ValueError(f"No data to save in \'{fnm}\'")\n        try:\n            p = cls.get_absolute_path(fnm)\n            with open(p, "w") as file:\n                file.write(data)\n            mLo.Lo.print(f"Saved string to file: {p}")\n        except Exception as e:\n            raise Exception(f"Could not save string to file: {p}") from e\n    @classmethod\n    def save_bytes(cls, fnm: PathOrStr, b: bytes) -> None:\n        if b is None:\n            raise ValueError(f"\'b\' is null. No data to save in \'{fnm}\'")\n        try:\n            p = cls.get_absolute_path(fnm)\n            with open(p, "b") as file:\n                file.write(b)\n            mLo.Lo.print(f"Saved bytes to file: {p}")\n        except Exception as e:\n            raise Exception(f"Could not save bytes to file: {fnm}") from e\n    @classmethod\n    def save_array(cls, fnm: PathOrStr, arr: List[list]) -> None:\n        if arr is None:\n            raise ValueError("\'arr\' is null. No data to save in \'{fnm}\'")\n        num_rows = len(arr)\n        if num_rows == 0:\n            mLo.Lo.print("No data to save in \'{fnm}\'")\n            return\n        try:\n            p = cls.get_absolute_path(fnm)\n            with open(p, "w") as file:\n                for j in range(num_rows):\n                    line = "\\t".join([str(v) for v in arr[j]])\n                    file.write(line)\n                    file.write("\\n")\n            mLo.Lo.print(f"Save array to file: {p}")\n        except Exception as e:\n            raise Exception(f"Could not save array to file: {fnm}") from e\n    @classmethod\n    def append_to(cls, fnm: PathOrStr, msg: str) -> None:\n        try:\n            p = cls.get_absolute_path(fnm)\n            with open(p, "a") as file:\n                file.write(msg)\n                file.write("\\n")\n        except Exception as e:\n            raise Exception(f"unable to append to \'{fnm}\'") from e\n    @classmethod\n    def zip_access(cls, fnm: PathOrStr) -> XZipFileAccess:\n        return mLo.Lo.create_instance_mcf(\n            XZipFileAccess, "com.sun.star.packages.zip.ZipFileAccess", (cls.fnm_to_url(fnm),)\n        )\n    @classmethod\n    def zip_list_uno(cls, fnm: PathOrStr) -> None:\n        zfa: XNameAccess = cls.zip_access(fnm)\n        names = zfa.getElementNames()\n        mLo.Lo.print(f"\\nZippendContents of \'{fnm}\'")\n        mLo.Lo.print_names(names, 1)\n    @staticmethod\n    def unzip_file(zfa: XZipFileAccess, fnm: PathOrStr) -> None:\n        raise NotImplementedError\n    @staticmethod\n    def read_lines(in_stream: XInputStream) -> List[str] | None:\n        lines = []\n        try:\n            tis = mLo.Lo.create_instance_mcf(XTextInputStream, "com.sun.star.io.TextInputStream")\n            sink = mLo.Lo.qi(XActiveDataSink, tis)\n            sink.setInputStream(in_stream)\n            while tis.isEOF() is False:\n                lines.append(tis.readLine())\n            tis.closeInput()\n        except Exception as e:\n            mLo.Lo.print(e)\n        if len(lines) == 0:\n            return None\n        return lines\n    @classmethod\n    def get_mime_type(cls, zfa: XZipFileAccess) -> str | None:\n        try:\n            in_stream = zfa.getStreamByPattern("mimetype")\n            lines = cls.read_lines(in_stream)\n            if lines is not None:\n                return lines[0].strip()\n        except UnoException as e:\n            raise Exception("Unable to get mime type") from e\n        mLo.Lo.print("No mimetype found")\n        return None\n    @classmethod\n    def zip_list(cls, fnm: PathOrStr) -> None:\n        try:\n            p = cls.get_absolute_path(fnm)\n            with zipfile.ZipFile(p, "r") as zip:\n                for info in zip.getinfo():\n                    mLo.Lo.print(info.filename)\n                    mLo.Lo.print("\\tModified:\\t" + str(datetime.datetime(*info.date_time)))\n                    mLo.Lo.print("\\tSystem:\\t\\t" + str(info.create_system) + "(0 = Windows, 3 = Unix)")\n                    mLo.Lo.print("\\tZIP version:\\t" + str(info.create_version))\n                    mLo.Lo.print("\\tCompressed:\\t" + str(info.compress_size) + " bytes")\n                    mLo.Lo.print("\\tUncompressed:\\t" + str(info.file_size) + " bytes")\n            mLo.Lo.print()\n        except Exception as e:\n            mLo.Lo.print(e)\n')
    __scriptmerge_write_module('ooodev/utils/date_time_util.py', b'from __future__ import annotations\nimport datetime\nimport numbers\nfrom typing import cast\nfrom . import lo as mLo\nfrom com.sun.star.util import DateTime as UnoDateTime\nclass DateUtil:\n    @staticmethod\n    def time_stamp(tz: datetime.timezone | None = None) -> str:\n        if tz is not None:\n            dt = datetime.datetime.now(tz)\n        else:\n            dt = datetime.datetime.now()\n        return dt.strftime("%Y-%m-%d %H:%M:%S")\n    @staticmethod\n    def date_from_number(value: numbers.Number) -> datetime.datetime:\n        if not isinstance(value, numbers.Real):\n            raise TypeError(f"Incorrect type. Excpected \'Number\' got {type(value).__name__}")\n        delta = datetime.timedelta(days=value)\n        dnull = cast(datetime.datetime, mLo.Lo.null_date)\n        return dnull + delta\n    @staticmethod\n    def date_to_number(date: datetime.datetime | datetime.date) -> float:\n        dnull = cast(datetime.datetime, mLo.Lo.null_date)\n        if isinstance(date, datetime.datetime):\n            delta = date - dnull\n        elif isinstance(date, datetime.date):\n            delta = date - dnull.date()\n        else:\n            raise TypeError(f"Incorrect type. Excpected \'date\' or \'datetime\' got {type(date).__name__}")\n        return delta.days + delta.seconds / (24.0 * 60 * 60)\n    @staticmethod\n    def time_from_number(value: numbers.Number) -> datetime.time | None:\n        if not isinstance(value, numbers.Real):\n            raise TypeError(f"Incorrect type. Excpected \'Number\' got {type(value).__name__}")\n        delta = datetime.timedelta(days=value)\n        minutes, second = divmod(delta.seconds, 60)\n        hour, minute = divmod(minutes, 60)\n        return datetime.time(hour, minute, second, tzinfo=datetime.timezone.utc)\n    @staticmethod\n    def time_to_number(time: datetime.time) -> float:\n        if not isinstance(time, datetime.time):\n            raise TypeError(f"Incorrect type. Excpected \'Number\' got {type(time).__name__}")\n        return ((time.second / 60.0 + time.minute) / 60.0 + time.hour) / 24.0\n    @staticmethod\n    def date_time_str(dt: datetime.datetime) -> str:\n        return dt.strftime("%b %d, %Y %H:%M")\n    @staticmethod\n    def uno_dt_to_dt(uno_dt: UnoDateTime) -> datetime.datetime:\n        if uno_dt.Year <= 0 or uno_dt.Month <= 0 or uno_dt.Day <= 0:\n            return mLo.Lo.null_date\n        td = datetime.datetime(\n            year=uno_dt.Year,\n            month=uno_dt.Month,\n            day=uno_dt.Day,\n            hour=uno_dt.Hours,\n            minute=uno_dt.Minutes,\n            second=uno_dt.Seconds,\n            microsecond=0 if uno_dt.NanoSeconds == 0 else int(uno_dt.NanoSeconds / 1000),\n            tzinfo=datetime.timezone.utc if uno_dt.IsUTC else None,\n        )\n        return td\n    @classmethod\n    def str_date_time(cls, uno_dt: UnoDateTime) -> str:\n        dt = cls.uno_dt_to_dt(uno_dt)\n        if dt == mLo.Lo.null_date:\n            return ""\n        return cls.date_time_str(dt)\n')
    __scriptmerge_write_module('ooodev/exceptions/__init__.py', b'')
    __scriptmerge_write_module('ooodev/exceptions/ex.py', b'from __future__ import annotations\nfrom typing import Any, List, TYPE_CHECKING\nfrom ..utils.type_var import PathOrStr\nif TYPE_CHECKING:\n    from ..events.args.event_args import EventArgs\nclass MissingInterfaceError(Exception):\n    def __init__(self, interface: Any, message: Any = None, *args) -> None:\n        if message is None:\n            try:\n                message = f"Missing interface {interface.__pyunointerface__}"\n            except AttributeError:\n                message = "Missing Uno Interface Error"\n        super().__init__(interface, message, *args)\n    def __str__(self) -> str:\n        return repr(self.args[1])\nclass CellError(Exception):\n    pass\nclass ConfigError(Exception):\n    pass\nclass PropertyError(Exception):\n    def __init__(self, prop_name: str, *args: object) -> None:\n        super().__init__(prop_name, *args)\n    def __str__(self) -> str:\n        return repr(f"Property Error for: {self.args[0]}")\nclass PropertiesError(Exception):\n    pass\nclass PropertyNotFoundError(PropertyError):\n    def __str__(self) -> str:\n        return repr(f"Property not found for: {self.args[0]}")\nclass GoalDivergenceError(Exception):\n    def __init__(self, divergence: float, message: Any = None) -> None:\n        if message is None:\n            message = f"Divergence error: {divergence:.4f}"\n        super().__init__(divergence, message)\n    def __str__(self) -> str:\n        return repr(self.args[1])\nclass UnKnownError(Exception):\n    pass\nclass UnOpenableError(Exception):\n    def __init__(self, fnm: PathOrStr, *args: object) -> None:\n        super().__init__(fnm, *args)\n    def __str__(self) -> str:\n        return repr(f"Un-openable file: \'{self.args[0]}\'")\nclass MultiError(Exception):\n    def __init__(self, errors: List[Exception]) -> None:\n        self.errors = errors\n        super().__init__(self.errors)\n    def __str__(self) -> str:\n        return "\\n".join([str(x) for x in self.errors])\nclass NotSupportedServiceError(Exception):\n    def __init__(self, service_name: str, *args: object) -> None:\n        super().__init__(service_name, *args)\n    def __str__(self) -> str:\n        return repr(f"Service not supported: \'{self.args[0]}\'")\nclass NotSupportedMacroModeError(Exception):\n    pass\nclass CreateInstanceError(Exception):\n    def __init__(self, interface: Any, service: str, message: Any = None, *args) -> None:\n        if message is None:\n            message = f"Unable to create instance of {service}"\n        super().__init__(interface, service, message, *args)\n    def __str__(self) -> str:\n        try:\n            interface_name = self.args[0].__pyunointerface__\n        except AttributeError:\n            interface_name = "Unknown Interface"\n        return f"Unable to create instance for service \'{self.args[1]}\' with interface of \'{interface_name}\'.\\n{self.args[2]}"\nclass CreateInstanceMsfError(CreateInstanceError):\n    pass\nclass CreateInstanceMcfError(CreateInstanceError):\n    pass\nclass CancelEventError(Exception):\n    def __init__(self, event_args: EventArgs, message: Any = None, *args) -> None:\n        if message is None:\n            message = f"Event \'{event_args.event_name}\' is canceled!"\n        super().__init__(event_args, message, *args)\n    def __str__(self) -> str:\n        return repr(self.args[1])\nclass CursorError(Exception):\n    pass\nclass WordCursorError(CursorError):\n    pass\nclass LineCursorError(CursorError):\n    pass\nclass SentenceCursorError(CursorError):\n    pass\nclass ParagraphCursorError(CursorError):\n    pass\nclass PageCursorError(Exception):\n    pass\nclass ViewCursorError(CursorError):\n    pass\nclass LoNotLoadedError(Exception):\n    pass\n')
    __scriptmerge_write_module('ooodev/utils/xml_util.py', b'from __future__ import annotations\nfrom typing import TYPE_CHECKING\nimport os\nfrom typing import Sequence, Tuple, List, overload\nfrom xml.dom.minidom import Node, parse, Document, parseString\nimport urllib.request\nfrom xml.dom.minicompat import NodeList\nfrom ..exceptions import ex as mEx\nfrom .table_helper import TableHelper\nfrom . import lo as mLo  \nfrom . import file_io as mFileIO\nfrom .type_var import PathOrStr\nclass XML:\n    @classmethod\n    def load_doc(cls, fnm: PathOrStr) -> Document:\n        try:\n            pth = mFileIO.FileIO.get_absolute_path(fnm)\n            with open(pth) as file:\n                doc = parse(file)\n            cls._remove_whitespace(doc)\n            doc.normalize()\n            return doc\n        except Exception as e:\n            print(e)\n            raise Exception(f"Opening of document failed: \'{fnm}\'") from e\n    @classmethod\n    def url_2_doc(cls, url: str) -> Document:\n        try:\n            with urllib.request.urlopen(url) as url_data:\n                doc = parseString(url_data.read().decode())\n            cls._remove_whitespace(doc)\n            doc.normalize()\n            return doc\n        except Exception as e:\n            print(e)\n            raise Exception(f"Opening of document failed: \'{url}\'") from e\n    @classmethod\n    def str_to_doc(cls, xml_str: str) -> Document:\n        try:\n            doc = parseString(xml_str)\n            cls._remove_whitespace(doc)\n            doc.normalize()\n            return doc\n        except Exception as e:\n            print(e)\n            raise Exception(f"Error get xml docoument from xml string") from e\n    @staticmethod\n    def save_doc(doc: Document, xml_fnm: PathOrStr) -> None:\n        try:\n            pth = mFileIO.FileIO.get_absolute_path(xml_fnm)\n            with open(pth, "w") as file:\n                sx: str = doc.toprettyxml(indent="  ")\n                lines = [line for line in sx.splitlines() if line.strip() != ""]\n                lines.append("")  \n                clean_sx = "\\n".join(lines)\n                file.write(clean_sx)\n        except Exception as e:\n            raise Exception(f"Unable to save document to {xml_fnm}") from e\n    @staticmethod\n    def get_node(tag_name: str, nodes: NodeList) -> Node | None:\n        name = tag_name.casefold()\n        for node in nodes:\n            if node.nodeType == Node.ELEMENT_NODE and node.tagName.casefold() == name:\n                return node\n        return None\n    @overload\n    @staticmethod\n    def get_node_value(node: Node) -> str:\n        ...\n    @overload\n    @staticmethod\n    def get_node_value(tag_name: str, nodes: NodeList) -> str:\n        ...\n    @classmethod\n    def get_node_value(cls, *args, **kwargs) -> str:\n        ordered_keys = (1, 2)\n        kargs_len = len(kwargs)\n        count = len(args) + kargs_len\n        def get_kwargs() -> dict:\n            ka = {}\n            if kargs_len == 0:\n                return ka\n            valid_keys = ("tag_name", "nodes", "node")\n            check = all(key in valid_keys for key in kwargs.keys())\n            if not check:\n                raise TypeError("get_node_value() got an unexpected keyword argument")\n            keys = ("tag_name", "node")\n            for key in keys:\n                if key in kwargs:\n                    ka[1] = kwargs[key]\n                    break\n            if count == 1:\n                return ka\n            ka[2] = kwargs.get("nodes", None)\n            return ka\n        if not count in (1, 2):\n            raise TypeError("get_node_value() got an invalid numer of arguments")\n        kargs = get_kwargs()\n        for i, arg in enumerate(args):\n            kargs[ordered_keys[i]] = arg\n        if count == 1:\n            return cls._get_node_val(kargs[1])\n        return cls._get_node_val2(kargs[1], kargs[2])\n    @staticmethod\n    def _get_node_val(node: Node) -> str:\n        if node is None:\n            return ""\n        if not node.hasChildNodes():\n            return ""\n        child_nodes: NodeList = node.childNodes\n        for node in child_nodes:\n            if node.nodeType == Node.TEXT_NODE:\n                return str(node.data).strip()\n        return ""\n    @classmethod\n    def _get_node_val2(cls, tag_name: str, nodes: NodeList) -> str:\n        if nodes is None:\n            return ""\n        name = tag_name.casefold()\n        for node in nodes:\n            if node.nodeName.casefold() == name:\n                return cls._get_node_val(node)\n        return ""\n    @classmethod\n    def get_node_values(cls, nodes: NodeList) -> Tuple[str, ...]:\n        vals = []\n        for node in nodes:\n            val = cls._get_node_val(node)\n            if val != "":\n                vals.append(val)\n        return tuple(val)\n    @staticmethod\n    def get_node_attr(attr_name: str, node: Node) -> str:\n        if node.attributes is None:\n            return ""\n        attrs = dict(node.attributes.items())\n        name = attr_name.casefold()\n        for k, v in attrs.items():\n            if str(k).casefold() == name:\n                return str(v)\n        return ""\n    @classmethod\n    def get_all_node_values(cls, row_nodes: NodeList, col_ids: Sequence[str]) -> List[list] | None:\n        num_rows = len(row_nodes)\n        num_cols = len(col_ids)\n        if num_cols == 0 or num_rows == 0:\n            return None\n        data = TableHelper.make_2d_array(num_rows=num_rows, num_cols=num_cols)\n        for col, _ in enumerate(col_ids):\n            data[0][col] = mLo.Lo.capitalize(col_ids[col])\n        for i, node in enumerate(row_nodes):\n            col_nodes = node.childNodes\n            for col in range(num_cols):\n                data[i][col] = cls.get_node_value(col_ids[col], col_nodes)\n        return data\n    @staticmethod\n    def apply_xslt(xml_fnm: PathOrStr, xls_fnm: PathOrStr) -> str:\n        if mLo.Lo.is_macro_mode:\n            raise mEx.NotSupportedMacroModeError("apply_xslt() is not supported from a macro")\n        try:\n            from lxml import etree as XML_ETREE\n        except ImportError as e:\n            raise Exception("apply_xslt() requires lxml python package") from e\n        _xml_parser = XML_ETREE.XMLParser(remove_blank_text=True)\n        try:\n            pth_xml = mFileIO.FileIO.get_absolute_path(xml_fnm)\n            pth_xls = mFileIO.FileIO.get_absolute_path(xls_fnm)\n            print(f"Applying filter \'{xls_fnm}\' to \'{xml_fnm}\'")\n            dom = XML_ETREE.parse(pth_xml, parser=_xml_parser)\n            xslt = XML_ETREE.parse(pth_xls)\n            transform = XML_ETREE.XSLT(xslt)\n            newdom = transform(dom)\n            t_result = XML_ETREE.tostring(newdom, encoding="unicode")  \n            return t_result\n        except Exception as e:\n            raise Exception(f"Unable to transform \'{xml_fnm}\' with \'{xls_fnm}\'") from e\n    @staticmethod\n    def apply_xslt_to_str(xml_str: str, xls_fnm: PathOrStr) -> str:\n        if mLo.Lo.is_macro_mode:\n            raise mEx.NotSupportedMacroModeError("apply_xslt_2_str() is not supported from a macro")\n        try:\n            from lxml import etree as XML_ETREE\n        except ImportError as e:\n            raise Exception("apply_xslt requires lxml python package") from e\n        _xml_parser = XML_ETREE.XMLParser(remove_blank_text=True)\n        try:\n            pth = mFileIO.FileIO.get_absolute_path(xls_fnm)\n            print(f"Applying the filter in \'{xls_fnm}\'")\n            dom = XML_ETREE.fromstring(xml_str)\n            xslt = XML_ETREE.parse(pth, parser=_xml_parser)\n            transform = XML_ETREE.XSLT(xslt)\n            newdom = transform(dom)\n            t_result = XML_ETREE.tostring(newdom, encoding="unicode")  \n            return t_result\n        except Exception as e:\n            raise Exception("Unable to transform the string") from e\n    @staticmethod\n    def get_flat_fiter_name(doc_type: mLo.Lo.DocTypeStr) -> str:\n        if doc_type == mLo.Lo.DocTypeStr.WRITER:\n            return "OpenDocument Text Flat XML"\n        elif doc_type == mLo.Lo.DocTypeStr.CALC:\n            return "OpenDocument Spreadsheet Flat XML"\n        elif doc_type == mLo.Lo.DocTypeStr.DRAW:\n            return "OpenDocument Drawing Flat XML"\n        elif doc_type == mLo.Lo.DocTypeStr.IMPRESS:\n            return "OpenDocument Presentation Flat XML"\n        else:\n            print("No Flat XML filter for this document type; using Flat text")\n            return "OpenDocument Text Flat XML"\n    @overload\n    @classmethod\n    def indent(cls, src: str) -> str:\n        ...\n    @overload\n    @classmethod\n    def indent(cls, src: os.PathLike) -> str:\n        ...\n    @overload\n    @classmethod\n    def indent(cls, src: Document) -> str:\n        ...\n    @classmethod\n    def indent(cls, src: os.PathLike | str | Document) -> str:\n        try:\n            if isinstance(src, os.PathLike):\n                with open(mFileIO.FileIO.get_absolute_path(src), "r") as file:\n                    doc = parse(file)\n            elif isinstance(src, str):\n                doc = parseString(src)\n            elif isinstance(src, Document):\n                doc = parseString(src.toxml())\n            else:\n                raise TypeError(\n                    f"src is not recognized. Expected, str, PathLike or Document. Got {type(src).__name__}"\n                )\n            cls._remove_whitespace(doc)\n            doc.normalize()\n            pretty_xml = doc.toprettyxml()\n            return pretty_xml\n        except TypeError:\n            raise\n        except Exception as e:\n            if isinstance(src, (str, os.PathLike)):\n                msg = f"Unable to indent \'{src}\'"\n            else:\n                msg = f"Unable to indent document"\n            raise Exception(msg) from e\n    @classmethod\n    def _remove_whitespace(cls, node):\n        if node.nodeType == Node.TEXT_NODE:\n            if node.nodeValue.strip() == "":\n                node.nodeValue = ""\n        for child in node.childNodes:\n            cls._remove_whitespace(child)\n')
    __scriptmerge_write_module('ooodev/utils/table_helper.py', b'from __future__ import annotations\nimport string\nfrom typing import Callable, Iterable, Iterator, Sequence, List, NamedTuple, Any, Tuple, cast, overload\nfrom inspect import isclass\nimport string\nfrom .type_var import DictTable, Table\nfrom . import gen_util as gUtil\nclass TableHelper:\n    @staticmethod\n    def col_name_to_int(name: str) -> int:\n        chars = name.rstrip(string.digits)\n        pow = 1\n        col_num = 0\n        for letter in chars[::-1]:  \n            col_num += (int(letter, 36) - 9) * pow\n            pow *= 26\n        return col_num\n    @staticmethod\n    def row_name_to_int(name: str) -> int:\n        chars = name.rstrip(string.digits + "-")\n        if chars:\n            s = name[len(chars)]  \n        else:\n            s = name\n        result = int(s)\n        if result < 0:\n            raise ValueError(f"Cannot parse negative values: {name}")\n        return result\n    @classmethod\n    def make_cell_name(cls, row: int, col: int) -> str:\n        if row < 1:\n            raise ValueError(f"row is one based. Value cannot be less then 1: {row}")\n        return f"{cls.make_column_name(col)}{row}"\n    @staticmethod\n    def make_column_name(col: int) -> str:  \n        if col < 1:\n            raise ValueError(f"col is one based. Value cannot be less then 1: {col}")\n        str_col = str()\n        div = col\n        while div:\n            (div, mod) = divmod(div - 1, 26)  \n            str_col = chr(mod + 65) + str_col\n        return str_col\n    @overload\n    @staticmethod\n    def make_2d_array(num_rows: int, num_cols: int) -> List[List[Any]]:\n        ...\n    @overload\n    @staticmethod\n    def make_2d_array(num_rows: int, num_cols: int, val: Any) -> List[List[Any]]:\n        ...\n    @overload\n    @staticmethod\n    def make_2d_array(num_rows: int, num_cols: int, val: Callable[[int, int, Any], Any]) -> List[List[Any]]:\n        ...\n    @staticmethod\n    def make_2d_array(num_rows: int, num_cols: int, val=None) -> List[List[Any]]:\n        if num_cols == 0 or num_rows == 0:\n            return []\n        if val is None:\n            val = 1\n        if callable(val):\n            data = []\n            new_val = None\n            for row in range(num_rows):\n                col_data = []\n                for col in range(num_cols):\n                    new_val = val(row, col, new_val)\n                    col_data.append(new_val)\n                data.append(col_data)\n        else:\n            data = [[val] * num_cols for _ in range(num_rows)]\n        return data\n    make_2d_list = make_2d_array\n    @staticmethod\n    def to_list(iter_obj: Iterable[Any] | object) -> List[Any]:\n        if gUtil.Util.is_iterable(iter_obj):\n            return list(iter_obj)\n        return [iter_obj]\n    @staticmethod\n    def to_tuple(iter_obj: Iterable[Any] | object) -> Tuple[Any]:\n        if gUtil.Util.is_iterable(iter_obj):\n            return tuple(iter_obj)\n        return (iter_obj,)\n    @classmethod\n    def to_2d_list(cls, seq_obj: Sequence[Any]) -> List[List[Any]]:\n        num_rows = len(seq_obj)\n        if num_rows == 0:\n            return []\n        is_2d = False\n        try:\n            is_2d = gUtil.Util.is_iterable(seq_obj[0])\n        except Exception:\n            is_2d = False\n        lst = []\n        if is_2d:\n            for row in seq_obj:\n                lst.append(cls.to_list(row))\n        else:\n            lst.append(cls.to_list(seq_obj))\n        return lst\n    @classmethod\n    def to_2d_tuple(cls, seq_obj: Sequence[Any]) -> Tuple[Tuple[Any, ...], ...]:\n        num_rows = len(seq_obj)\n        if num_rows == 0:\n            return tuple()\n        is_2d = False\n        try:\n            is_2d = gUtil.Util.is_iterable(seq_obj[0])\n        except Exception:\n            is_2d = False\n        lst = []\n        if is_2d:\n            for row in seq_obj:\n                lst.append(cls.to_tuple(row))\n        else:\n            lst.append(cls.to_tuple(seq_obj))\n        return tuple(lst)\n    @staticmethod\n    def table_2d_to_dict(tbl: Table) -> DictTable:\n        if len(tbl) < 2:\n            raise ValueError("Cannot convert Table with less than two rows")\n        try:\n            cols = [value for value in tbl[0]]\n            data = []\n            for i, row in enumerate(tbl):\n                if i == 0:  \n                    continue\n                data.append(dict(zip(cols, row)))\n            return data\n        except Exception as e:\n            raise e\n    @staticmethod\n    def table_dict_to_table(tbl: DictTable) -> Table:\n        if len(tbl) == 0:\n            raise ValueError("Cannot convert table with no rows")\n        try:\n            first = tbl[0]\n            cols = [k for k in first.keys()]\n            data = [cols]\n            for row in tbl:\n                data.append([v for _, v in row.items()])\n            return data\n        except Exception as e:\n            raise e\n')
    __scriptmerge_write_module('ooodev/utils/gen_util.py', b'from __future__ import annotations\nfrom typing import Iterable, Iterator, NamedTuple, Any\nfrom inspect import isclass\nclass ArgsHelper:\n    class NameValue(NamedTuple):\n        name: str\n        value: Any\nclass Util:\n    @classmethod\n    def is_iterable(cls, arg: object, excluded_types: Iterable[type] | None = None) -> bool:\n        if excluded_types is None:\n            excluded_types = (str,)\n        result = False\n        try:\n            result = isinstance(iter(arg), Iterator)\n        except Exception:\n            result = False\n        if result is True:\n            if cls._is_iterable_excluded(arg, excluded_types=excluded_types):\n                result = False\n        return result\n    @staticmethod\n    def _is_iterable_excluded(arg: object, excluded_types: Iterable) -> bool:\n        try:\n            isinstance(iter(excluded_types), Iterator)\n        except Exception:\n            return False\n        if len(excluded_types) == 0:\n            return False\n        def _is_instance(obj: object) -> bool:\n            try:\n                if not isinstance(obj, obj):\n                    return False\n            except TypeError:\n                pass\n            return True\n        ex_types = excluded_types if isinstance(excluded_types, tuple) else tuple(excluded_types)\n        arg_instance = _is_instance(arg)\n        if arg_instance is True:\n            if isinstance(arg, ex_types):\n                return True\n            return False\n        if isclass(arg) and issubclass(arg, ex_types):\n            return True\n        return arg in ex_types\n')
    __scriptmerge_write_module('ooo/dyn/awt/__init__.py', b'')
    __scriptmerge_write_module('ooo/dyn/awt/message_box_results.py', b'from enum import IntEnum\nfrom typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    from ooo.helper.enum_helper import UnoConstMeta, ConstEnumMeta\n    class MessageBoxResults(metaclass=UnoConstMeta, type_name="com.sun.star.awt.MessageBoxResults", name_space="com.sun.star.awt"):\n        pass\n    class MessageBoxResultsEnum(IntEnum, metaclass=ConstEnumMeta, type_name="com.sun.star.awt.MessageBoxResults", name_space="com.sun.star.awt"):\n        pass\nelse:\n    from ...lo.awt.message_box_results import MessageBoxResults as MessageBoxResults\n    class MessageBoxResultsEnum(IntEnum):\n        CANCEL = MessageBoxResults.CANCEL\n        OK = MessageBoxResults.OK\n        YES = MessageBoxResults.YES\n        NO = MessageBoxResults.NO\n        RETRY = MessageBoxResults.RETRY\n        IGNORE = MessageBoxResults.IGNORE\n__all__ = [\'MessageBoxResults\', \'MessageBoxResultsEnum\']\n')
    __scriptmerge_write_module('ooo/lo/awt/__init__.py', b'')
    __scriptmerge_write_module('ooo/lo/awt/message_box_results.py', b"class MessageBoxResults(object):\n    __ooo_ns__: str = 'com.sun.star.awt'\n    __ooo_full_ns__: str = 'com.sun.star.awt.MessageBoxResults'\n    __ooo_type_name__: str = 'const'\n    CANCEL = 0\n    OK = 1\n    YES = 2\n    NO = 3\n    RETRY = 4\n    IGNORE = 5\n__all__ = ['MessageBoxResults']\n")
    __scriptmerge_write_module('ooo/dyn/awt/message_box_buttons.py', b'from enum import IntEnum\nfrom typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    from ooo.helper.enum_helper import UnoConstMeta, ConstEnumMeta\n    class MessageBoxButtons(metaclass=UnoConstMeta, type_name="com.sun.star.awt.MessageBoxButtons", name_space="com.sun.star.awt"):\n        pass\n    class MessageBoxButtonsEnum(IntEnum, metaclass=ConstEnumMeta, type_name="com.sun.star.awt.MessageBoxButtons", name_space="com.sun.star.awt"):\n        pass\nelse:\n    from ...lo.awt.message_box_buttons import MessageBoxButtons as MessageBoxButtons\n    class MessageBoxButtonsEnum(IntEnum):\n        BUTTONS_OK = MessageBoxButtons.BUTTONS_OK\n        BUTTONS_OK_CANCEL = MessageBoxButtons.BUTTONS_OK_CANCEL\n        BUTTONS_YES_NO = MessageBoxButtons.BUTTONS_YES_NO\n        BUTTONS_YES_NO_CANCEL = MessageBoxButtons.BUTTONS_YES_NO_CANCEL\n        BUTTONS_RETRY_CANCEL = MessageBoxButtons.BUTTONS_RETRY_CANCEL\n        BUTTONS_ABORT_IGNORE_RETRY = MessageBoxButtons.BUTTONS_ABORT_IGNORE_RETRY\n        DEFAULT_BUTTON_OK = MessageBoxButtons.DEFAULT_BUTTON_OK\n        DEFAULT_BUTTON_CANCEL = MessageBoxButtons.DEFAULT_BUTTON_CANCEL\n        DEFAULT_BUTTON_RETRY = MessageBoxButtons.DEFAULT_BUTTON_RETRY\n        DEFAULT_BUTTON_YES = MessageBoxButtons.DEFAULT_BUTTON_YES\n        DEFAULT_BUTTON_NO = MessageBoxButtons.DEFAULT_BUTTON_NO\n        DEFAULT_BUTTON_IGNORE = MessageBoxButtons.DEFAULT_BUTTON_IGNORE\n__all__ = [\'MessageBoxButtons\', \'MessageBoxButtonsEnum\']\n')
    __scriptmerge_write_module('ooo/lo/awt/message_box_buttons.py', b"class MessageBoxButtons(object):\n    __ooo_ns__: str = 'com.sun.star.awt'\n    __ooo_full_ns__: str = 'com.sun.star.awt.MessageBoxButtons'\n    __ooo_type_name__: str = 'const'\n    BUTTONS_OK = 1\n    BUTTONS_OK_CANCEL = 2\n    BUTTONS_YES_NO = 3\n    BUTTONS_YES_NO_CANCEL = 4\n    BUTTONS_RETRY_CANCEL = 5\n    BUTTONS_ABORT_IGNORE_RETRY = 6\n    DEFAULT_BUTTON_OK = 65536\n    DEFAULT_BUTTON_CANCEL = 131072\n    DEFAULT_BUTTON_RETRY = 196608\n    DEFAULT_BUTTON_YES = 262144\n    DEFAULT_BUTTON_NO = 327680\n    DEFAULT_BUTTON_IGNORE = 393216\n__all__ = ['MessageBoxButtons']\n")
    __scriptmerge_write_module('ooo/dyn/awt/message_box_type.py', b'from typing import TYPE_CHECKING\nfrom ooo.oenv.env_const import UNO_ENVIRONMENT, UNO_RUNTIME\n_DYNAMIC = False\nif (not TYPE_CHECKING) and UNO_RUNTIME and UNO_ENVIRONMENT:\n    _DYNAMIC = True\nif not TYPE_CHECKING and _DYNAMIC:\n    from ooo.helper.enum_helper import UnoEnumMeta\n    class MessageBoxType(metaclass=UnoEnumMeta, type_name="com.sun.star.awt.MessageBoxType", name_space="com.sun.star.awt"):\n        pass\nelse:\n    from ...lo.awt.message_box_type import MessageBoxType as MessageBoxType\n__all__ = [\'MessageBoxType\']\n')
    __scriptmerge_write_module('ooo/lo/awt/message_box_type.py', b"from enum import Enum\nclass MessageBoxType(Enum):\n    __ooo_ns__: str = 'com.sun.star.awt'\n    __ooo_full_ns__: str = 'com.sun.star.awt.MessageBoxType'\n    __ooo_type_name__: str = 'enum'\n    @property\n    def typeName(self) -> str:\n        return 'com.sun.star.awt.MessageBoxType'\n    ERRORBOX = 'ERRORBOX'\n    INFOBOX = 'INFOBOX'\n    MESSAGEBOX = 'MESSAGEBOX'\n    QUERYBOX = 'QUERYBOX'\n    WARNINGBOX = 'WARNINGBOX'\n__all__ = ['MessageBoxType']\n")
    # coding: utf-8
    from lib.msgbox import msgbox, MessageBoxButtonsEnum, MessageBoxResultsEnum, MessageBoxType
    
    
    def msg_small(*args, **kwargs):
        msg = "A small message"
        result = msgbox(
            message=msg,
            title="Short",
            buttons=MessageBoxButtonsEnum.BUTTONS_OK,
            boxtype=MessageBoxType.INFOBOX,
        )
        assert result == MessageBoxResultsEnum.OK
        print(result)
    
    
    def msg_long(*args, **kwargs):
        msg = (
            "A very long message A very long message A very long message A very long message "
            "A very long message A very long message A very long message A very long message "
            "A very long message A very long message"
            "\n\n"
            "Do you agree ?"
        )
        result = msgbox(
            message=msg,
            buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
            title="Long...",
            boxtype=MessageBoxType.QUERYBOX,
        )
        assert result == MessageBoxResultsEnum.YES or MessageBoxResultsEnum.NO
        print(result)
    
    
    def msg_default_yes(*args, **kwargs):
        msg = "This dialog as button set to a defalt of yes."
        result = msgbox(
            message=msg,
            buttons=(MessageBoxButtonsEnum.BUTTONS_YES_NO.value | MessageBoxButtonsEnum.DEFAULT_BUTTON_YES.value),
            title="Default",
            boxtype=MessageBoxType.MESSAGEBOX,
        )
        assert result == MessageBoxResultsEnum.YES or MessageBoxResultsEnum.NO
        print(result)
    
    
    def msg_error(*args, **kwargs):
        msg = "Looks like an error!"
        result = msgbox(
            message=msg,
            title="\U0001F6D1 Opps",
            buttons=MessageBoxButtonsEnum.BUTTONS_OK,
            boxtype=MessageBoxType.ERRORBOX,
        )
        assert result == MessageBoxResultsEnum.OK
        print(result)
    
    
    def msg_warning(*args, **kwargs):
        msg = "Looks like a Warning!"
        result = msgbox(
            message=msg,
            title="\u26A0 \U0001F440",
            buttons=MessageBoxButtonsEnum.BUTTONS_OK,
            boxtype=MessageBoxType.WARNINGBOX,
        )
        assert result == MessageBoxResultsEnum.OK
        print(result)
    
g_exportedScripts = (msg_small,msg_long,msg_default_yes,msg_error,msg_warning)
